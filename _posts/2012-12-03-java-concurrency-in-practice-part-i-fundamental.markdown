---
author: Bear
comments: true
date: 2012-12-03 17:25:40
layout: post
slug: java-concurrency-in-practice-part-i-fundamental
title: Java并发编程笔记-PART I.基本原理
wordpress_id: 80
categories:
- Java Concurrency in Practice
- 笔记
tags:
- concurrency
- Java并发编程
- reading note
---

 学了好几年的编程，对于多线程一直没有进门，反复看了好多Java入门书籍顺带的多线程，无法顿悟其奥义。这本Java Concurrency In Practice，希望能解决我多年来的苦恼，所以好好读，做读书笔记，概括每章节的内容。一共有4个部分组成，每个部分一篇笔记。

Chapter 1 - Introduction

这章比较简单如小标题，就是介绍多线程。由于以前的计算机比较落后都是单进程在跑，后来多核CPU出现了，多进程出现了，CPU处理任务的粒度越来越小了，非阻塞IO出现了，渐渐的多线程也变得越来越重要了。那以人的直觉以及处理事情的方式，基本处于单线程，所以我们不能以人类的思维来编程，因为这样可能会浪费99%的CPU资源，同时拖延任务处理时间。应该让计算机更有效率的处理问题，这里随便插一句，其实计算机本身没什么屌的，所有厉害之处就是它做算术比人类快了n次方倍，所以它牛。

再分析了一遍Java多线程是把双刃剑。

列了几点好处：1.能高效利用多核处理器2.编程模型更简单3.处理异步事件更简洁4.用户界面反应更快捷。

也列了几点坏处：1.线程安全风险2.活性(活锁,死锁,饥饿)风险3.性能风险。
<!-- more -->
最后总结说多线程无处不在。我忽然就记起来最早学习多线程是初中的语文书= =.那是个单元小结，告诉我们怎样正确的泡茶:在等待开水烧开时，把洗茶杯倒茶叶之类的事情都做了，然后就可以泡茶了。好像是这样的剧情。在本章节里也出现了这个英语版...回想起来觉得好有趣，语文课学了计算机的知识，真是科学哲学不分家啊。

PART I fundamental 第一部分(2-5章节) 基础原理

Chapter 2 - Thread Safety

线程安全是多线程编程中最需要考量的问题，都不能保证程序正确，那多线程了有个屁用。那到底什么是线程安全?解释这个概念不容易，作者给了这样的定义:A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.(一个类如果是线程安全的，那么在运行环境无论多个线程按时序或者交叉的调用它，它的表现都正常，并且无需在调用这个类的线程代码里增加同步或者其他协调的代码。)

1.线程安全是要保证原子性(Atomicity)的，因为有多线程操作，必须做到操作不可拆分，否则容易做到一半频道切换给别的线程了，就捅篓子了。

2.上面的切频道这个就涉及到竞争条件(Race Condition)：结果必须依赖事件发生的时间而定。若做一半切频道再回来可能结果就会发生不同。往往会造成莫名其妙的错误。

3.上面的情况往往是在做Compound Actions(组合操作)的会遇到竞争条件，所以我们必须确保把多个动作捆绑起来一起完成，要么不做，要么做全套。

4.做全套用什么方法比较合适，锁的概念就出现了。在执行一段逻辑代码时，我们给这段逻辑加锁，加锁的意义就在于，这段逻辑同时只能有一个线程执行。这就是同步机制(Synchronizaiton)。

5.虽然只能由一个线程调用，但如果一个线程循环调用了这段逻辑怎么办?Reentrancy(可重入)意味着在因为循环调用或者系统中断后依然能得到正确的结果，JVM会给一个计数，线程增加调用则+1，结束调用则-1，当计数恢复为0，则解锁。

6.并不是只有在写入数据才需要锁，这个想法是错误的。在多个线程同时对一个数据进行操作时，我们必须要用锁来保证这个数据的状态，即用锁维护状态(Guarding State With Locks)

7.线程安全往往是在减低性能的，一段被加锁的逻辑往往是瓶颈所在。所以在用同步机制时必须很清楚知道程序的逻辑是否全部需要，应该考虑在尽量少的部分用，并且不在一些耗时很长的地方(如等待IO处理之流)。

8.在做到线程安全的基础上，尽量少的阻碍性能，不要让多线程的代码最终变成了单线程效果。

Chapter 3 - Sharing Objects

既然多线程，肯定会遇到多个线程共享一个对象的情况。

1.可见性(Visibility)，是指当对象改变时，任何线程都能知道，同步机制可以做到。当多个线程共享对象时，最稳妥的方式就是加同步机制。这涉及到过期数据(Stale Data)，某一线程读取到的是改变之前的对象数据，这在高速计算中是不能容忍的。double和long型不是原子的，因为它们是64位，JVM的原子操作是32位的，所以在多线程中也必须注意这个，加锁或者加volatile修饰符。锁不是只针对互斥现象，它也关系到内存可见性，为确保线程能得到到最新的共享变量，读写线程必须用公共锁保持同步。

2.volatile修饰符，是Java自带的，对比synchronized，它是一个轻量级的同步机制。它不会上锁所以无法对线程造成阻塞，所以在性能上是优于synchronized的。锁能保证可见性与一致性，但volatile只能保证可见性。volatile变量在多线程情况做自增(++)运算时可能会发生错误，因为无法保证原子性，除非自增操作只有单一线程操作。如果牵涉到不变式(X < Y)也是不适用volatile的。总结一下volatile的使用：

a).写变量不依赖现有值或者确保只有单个线程会更新值。

b).变量不参与不变式。

c).在访问变量时不需要其他原因的锁定。

3.把成员变量展现给其他类，称为公开(Publication)，但是在对象没有完整构造之前成员变量被引用了，则称为逃逸(Escape)。

4.线程限制(Thread Confinement)，当可以不用共享时，使用线程限制，让多线程各行其道互不干扰。

a)非正式线程限制(Ad-hoc Thread Confinement)，在局部使用单线程…

b)栈局限(Stack Confinement)，通过本地变量创建拷贝某个共享对象

c)ThreadLocal , Java类型，一个线程对应一个ThreadLocal，类似本地变量。

5.不变性(Immutability)，常量对线程来说是绝对安全的。善用Final变量。

6.安全公开(Safe Publication) 安全公开一个对象，在同一时刻此对象的引用以及状态都必须对其他线程可见，一个完整构建的对象可以在如下条件被安全公开:

a)从静态初始化程序初始化对象。

b)存储引用用volatile修饰符或AtomicReference类型引用。

c)存储引用用final修饰符修饰

d)存储引用有锁守护

7.在并发编程中共享对象最有效的策略如下：

a)一个线程唯一拥有一个线程限制的对象，只有这个线程能对其进行修改。

b)只读对象可以被任何线程访问并不需要增加同步机制。

c)线程安全对象，有内在同步机制，不需要更多的同步机制。

d)锁守护的对象。

Chapter 4 - Composing Objects

这章巴拉巴拉一堆就是说，用线程安全的组件或者变量，来组装一个更大的组件，对象或者程序，这样我们就不用费心分析我们的程序是否是线程安全的。内容跳过…因为我也看的迷迷糊糊的。

Chapter 5 - Building Blocks

这章重点介绍了并发的构成模块，以及使用库里提供的并发类时会遇到的一些问题。

1.同步集合载体(Synchronized Collections)不能保证在使用的过程中一定是线程安全的。sychronized类方法只能保证在同一个时间片内此类实体被一个sychronized方法调用，但不能保证调用顺序是你所设想的，比如在调用size()方法后再调用get()时，中间可能会被remove()打断过，结果错误还是不能避免的会发生。

2.在调用多个synchronized方法并且前后有关联时(比如get()与remove())，最好用到同步块，锁定操作的集合对象就能避免发生不同步问题。

3.使用迭代器(Iterators)时，部分迭代器(应该是大部分具体我不是很清楚)有fail-fast机制，即在用迭代器时若改变了原集合的结构，则立即抛出Concurrentmodificationexception，但是若用iterators自带的remove()等，则不会抛出异常，因为这个操作和迭代器维护着是同一套索引。

4.还要注意一些隐蔽的迭代器，比如在集合的toString()方法中就用到了迭代器，这经常会忽略在同步块之外，造成一些显示错误。

5.Java 5.0增加的java.util.concurrent.*包里有很多好东西。并发更强悍的并发集合(Concurrent Collections)在某些场景可以很好的取代同步集合(Synchronized Collections). http://www.ibm.com/developerworks/cn/java/j-5things4.html 这篇文章对CopyOnWriteArrayList，BlockingQueue，ConcurrentMap等集合容器都做了讨论，更多细节可以搜索，我还打算写一篇ConcurrentHashMap解析的文章，因为这个类真的蛮经典的。

6.生产者-消费者模式(Producer-consumer Pattern)，学过操作系统原理都应该知道，这是建立在上述所说的阻塞队列(Blocking Queue)上的一种模式，阻塞队列又分位无界队列和有界队列，有界队列是一个很棒的资源管理工具，让程序更加健壮可用。

7.阻塞方法(Blocking Method)能被中断(Interrupt)，阻塞状态是指BLOCKED，WAITING，TIMED_WAITING.

8.Java库提供了很多同步装置类，方便管理联系各线程状态。

a)Latches(锁存器) , 锁存器就像一个门，在到最终状态之前，门是关着，任何线程都不能通过。到达最终状 态后，再也不能改变，锁存器将保持打开状态允许线程通过。CountDownLatches的例子很多 自行搜索。

b)FutureTask，类似给异步请求做了代理，Furture.get依赖于任务状态，若已完成则立即返回，否则阻塞直到返回结果。在程序中，可以先创建FutureTask，再执行其他动作，等到要用到Task时，再get，相当于并发的异步请求。

c)Semaphores(信号量)，学过操作系统原理的也肯定熟悉，信号量可以控制激活有限数量的线程，让机器在满负荷而不是超负荷工作。比如数据库连接池就可以用信号量控制连接数。详细就不说了，比较常见。

d)Barriers(栅栏)，相对比Latches，是其增强版，Latches只能用一次，Barriers可以重复使用，Latches是对事件触发，Barriers是对线程触发。集齐七个线程，才能召唤神龙…只有等所有线程都完成时，Barriers才能让他们通过，进行到下一步。

Summary of Part I

第一部分基础原理就结束了，总结时间，原文几个点很到位，原封不动的翻译到这儿。

* 记住这是互斥状态，二货。(*It's economy,stupid典故戳中笑点啊混蛋) 所有的并发问题都归结于处理互斥状态的协调，越少互斥状态，线程越安全。
* 字段标识为Final除非它是变量。
* 不可变对象是线程安全的。不可变对象对于多线程有着可观的简化效果，它们更简单更可靠，并且能在不加锁以及无需防御性拷贝的情况下共享。
* 对于处理复杂问题，封装十分有效。你可以把所有数据存在全局变量中来打造一个线程安全的程序是没有意义的。往对象封装数据对于保护他们的不变量变得更简单，往对象封装同步语法对于遵守同步协议变得更简单。
* 对每个易变变量加锁守护。
* 组合动作(事务)持有锁。
* 能让多个线程在没有同步机制的情况下访问易变变量的程序是2B程序。
* 不要想当然的认为不需要同步机制。
* 设计构造中明确说明线程安全问题的，可以证明你的类是线程不安全的。
* 明文记录同步策略。

1/4 to be continue.
