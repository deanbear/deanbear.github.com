---
layout: post
title: 2013年TopCoder竞赛笔记
date: 2013-08-18 17:11:59
categories:
- 技术流/techgangster 
tags:
- TopCoder
- Programming
- algorithm
- SRM
---
讀書的時候，在NIT埋頭搞了一年多的ACM，後面轉學了，到ZJUT的時候又稍微玩了個把月拿了個校一等獎就去實習了，後面的兩年就沒再接觸過編程競賽了。今年搬家和新室友住一起，其中一個是ACMer，參加過WorldFinal，工作之後還有在堅持玩競賽。所以我這把年紀才開始玩TopCoder就是由他帶起的。

讀書的時候也有聽說TopCoder，並且伴着許多傳說，比如“XXX在上面贏了XX萬美刀的獎金”，“XXX憑着TopCoder的成績拿了多少多少萬年薪”之類的。當然，每個行業都有這樣的天才人物。我這種小脆皮根本和這樣的傳說搭不上邊，當然沒有啥好說的。但既然上了這條賊船，讓自己變的更強大也是理所應當的。這樣也表明自己弱雖弱，但有一顆上進的心嘛。並且做做編程算法是肯定有好處的，因爲編程本身就是另外一種思考方式。

TopCoder的賽制啊判分標準之類的我還不熟，待以後玩利落了再來八一八。現在一個月2-3次的比賽，一场2小时左右(SRM,Single Round Match)，頻率和时间還是很适合大部分工作了的程序员的。我現在還在Division 2，也就是菜鳥的範疇中，努力升級至Div1中> <

我在Topcoder上寫過的代碼都會託管在github上，[點擊這](https://github.com/deanbear/TopCoder)。並且在這篇文章會定期更新代碼思路。

Get fun from programming. May the force be with you.

***

###SRM595 2013/10/25

2013/11/17 update

最近工作忙碌且變化多，所以根本沒有時間精力做題、參加比賽。趁最近還算相對穩定，把欠的還上一些。SRM595沒時間參加，24號通宵發布完，25號9點實在爬不起來了。

- LittleElephantAndBallsAgain

  找到最長的那個相同字符串，然後總數減掉它就是答案了。

- LittleElephantAndIntervalsDiv2

  這題我第一眼看發現是線段樹類型的問題差點驚慌失措，但是由於數量級比較小，所以可以用暴力。
  
  模擬整個粉刷的過程，用一個數組Array[]標記這個坐標點最終被粉刷的結果(用一個遞增數字就可以表示)。最後將Array[]中的數字導入Set中，去重，就可以得到有set.size就是被劃分爲n塊互不相關的粉刷塊，每塊有2種顏色，所以是2^n 種結果。
  
- LittleElephantAndXor

  不是我獨立解出來的，參考了別人的代碼。很驚訝於做出來的人的代碼結構之簡潔，邏輯之清晰，有的時候總有一種「爲什麼這個世界上這麼多天才而我不是」的感嘆。
  
  題意以及引申意就是給定A，B，C，爲三個上限，X <= A，Y <= B，Z <= C，要求是X ^ Y == Z的数量。
  
  解釋一下^ 符號，是二進制中的異或(xor)。以下爲其表現：
  
  		1 ^ 0 = 1

  		1 ^ 1 = 0

  		0 ^ 0 = 0

  		0 ^ 1 = 1
  
  所以就是利用1)三值小於三上限，2)且X ^ Y == Z 這兩個約束條件進行全盤遞歸，同時由於這個遞歸的堆棧巨大，需要用到狀態保存，將之前已經遞歸過的結果存放在數組中，下次就不必再重複遞歸。
  
  DFS + DP，非常完美非常酷的題目與解法。具體還是看代碼多思考吧，只可意會不可言傳。
  
[看SRM595的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM595)

###SRM594 2013/10/15

2013/10/31 update

真是氣死我了。時間看錯了，遲登錄了一小時，本來打算開250pt做掉的。但是寫代碼還是太慢了，Compile的時候就結束了哭。然後就0分了，Challenge也沒有得逞。總分數就悲劇的從1009降到862。下次我要復仇！

- FoxAndClassroom
  
  一個矩形，如何才能在不斷取模的情況下，讓[x,y]坐標移動填滿整個矩形？這題由於數據量小，我直接用暴力記錄，取模，記錄取模，直到重複。最後探測是否整個矩形都遍歷了。
  
  更數學的做法就是判斷矩形長與寬的關係。假設長爲m寬爲n如果能同時被[2,10]中的某個數整除，那麼就是Impossible。爲什麼是[2,10]？因爲題目就要求這樣呀...
  
- AstronomicalRecordsEasy

  這題我就覺得是某種很熟悉的dp。但是因爲老了，忘記了...最後看了一下別人的實現。有點類似Longest Common Sequence(LCS)。
  
  序列 A1 A2 A3與 B1 B2 B3，如果他們是有序且以同一個基數遞增的，則會有以下等式：
  
  A1 * B2 = A2 * B1
  
  A2 * B3 = A3 * B2
  
  這題就是靠這個特質，不斷以一個子序列作爲基礎做這樣的運算，然後根據dp[i][j]+1來記錄最大的匹配。
  
- FoxAndGo2

  這道題目拉拉扯扯修修改改也做了一週多。由於太忙了，經常會被人打斷，所以都是零碎的時間在想在修改，今天過掉了還是很開心的。
  
  首先，一定要用dfs或者bfs把整個輪廓給搜索出來。
  
  然後，這其實類似圍棋，黑棋把白棋圍住就可以吃掉它們。但是如果沒有伴隨空格，黑棋會被反吃，即是自殺。所以包圍一個白棋"component"的黑棋"component"們裏必須至多有一個沒有伴隨空格，或者黑棋"component"裏有空餘自由的棋子。空餘自由棋子的定義就是和要包圍的白棋"component"沒有相交。這樣可以保證落子的時候是可以把這些自由棋子置空變成空格以完成在規則允許下對白棋的圍剿。
  
  最後，每次圍剿完一個白棋"component"，就要刷新一下黑棋的構成，因爲會多出很多空格以及自由棋子，這樣就可以擴大勢力繼續吃下去。
  
[看SRM594的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM594)

###SRM593 2013/10/05

2013/10/20 update

5號還在家也沒有網絡。長假回來後補做的。

- RaiseThisBarn

  切割遍歷數組計數。so easy.

- WolfDelaymaster

  如果你不知道世界上有正則表達式這樣的東西，那麼這題需要比較巧妙的邏輯構造了。我直接拋了一個Java的正則表達式上去就過了(搜索了一下C++標準庫居然好像沒有regex)

- MayTheBestPetWin

  這是我第一次題沒看懂是什麼意思。看了別人的源碼才知道題目說的是什麼，艹。說組成兩隊，每個個體都有一個戰鬥力浮動區間，所以每隊都有最壞以及最好的兩種表現。題意就是A隊最差與B隊最好以及A隊最好與B隊最差中，選差距大的一個，然後在此基礎上，求分組使得這個差距最小。繞啊繞啊繞。
  
  然後的思路是一個很巧妙的數學構造。總和與差數的巧妙變化。語文不好看代碼比較容易懂。

[看SRM593的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM593)



###SRM592 2013/09/27

2013/10/14 update

中規中矩的做了兩道題，分數漲了50pts左右，到1000pts出頭了。本次的Div2排名卻還不如SRM591，只排在Div2的180左右。

- LittleElephantAndBooks

  排序，拿出最小的前n-1以及第n+1個。

- LittleElephantAndPermutationDiv2

  如果沒做SRM591，我可能這題也是做不出來的。因爲有了591 Div2的500pts的題目ConvertibleStrings做鋪墊，這題更簡單，蠻好想到的。
  
  題意是讓你找出所有Magic和大於給定K的組合。固定一個數列A，讓另外一個數列B做next_permutation。這樣可以拿到A的一個固定排列對應的所有組合答案，所以還要對A做一次全排列才能拿到所有排列，所以答案還得乘以N!，N爲A數列的個數。

- LittleElephantAndArray

  這題最關鍵的一個地方，如果能從O(n^3 )降到O(n^2 )那麼就可以通過，否則就是Time Limit Exceeded。其实TopCoder在设置2s超时这件事情上还是下手很轻的。
  
  題意是給定N個連續Long Long型數字，每個數字可以對數位做縮減，但是最少要留下一位。問能組成多少組非降序數列。
  
  第一步是把每個數字做一次所有情況的縮減，所有數字的組合數(不排除組合出來的是相同的數字)應該是2^n ，n爲這個數字的位數。我用Map來記錄的，Key縮減出來的數字，Value爲共有多少個這個數字。再做一次升序排序，方便下一步處理。
  
  第二步就是把完成的所有組合開始拼數列。這裏面就是涉及到一個很厲害的把O(n^2 )降到O(C*n)的技巧(與上面說的有出入因爲外面還套了個大循環不算，屬於編程技巧)。
  
  比如你有两组数字组合，A(1,2,12)，B(2,3,23)，为了做出非降序数列，最简单的是对每个B匹配所有A的可能，然后记录下。比如B(2)循环一遍A(1,2,12)，B(3)也是，B(23)也是。所以就会是3*3=9次的遍历。那巧妙一些，B(2)通吃A(1,2)，启动一个计数SUM=2，然B(2)对A(12)无能为力，换B(3)，B(3)情况与B(2)也是一样的，SUM=2，然后B(23)时，在SUM=2的基础上，吃了A(12)，则SUM=3。所以答案为2+2+3=7。巧妙之处就是A只要遍历一次就好了。所以遍历降到1\*2+1\*1+1\*1=4。

[看SRM592的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM592)

###SRM591 2013/09/17

2013/10/06 update

這場比賽蠻搞笑的，我雖然只做了250pts的題目，但是在500pts上我Challenge了3題，2 Success 1 Fail，多賺了75pts共計290+排名Div2的127名，分數也漲到900+，僥倖從灰色變爲綠色了。我只能說從別人的代碼裏找漏洞的感覺太爽了。

- TheArithmeticProgression

  題目簡單，只是很繞，就是說如何使得a+c=2b能順利相等，要麼a+c+x? =2b，要麼a+c=2(b+y?)，選擇x?還是y?，則根據min(|x?|,|y?|)來決定。

- ConvertibleStrings

  這道題目在比賽時沒做出來，也忘記了C++中還有很好用的字典排序函數next_permutation。覺得很多人肯定會往簡單的想，直接用貪心水過，當時想了個特殊情況，自己沒做出來也不能讓別人好過呀。然後在Challenge階段直接用這個數據幹掉了2個，當時那個爽。然後就很賤的想直接憑藉這個數據多幹掉幾個人，然後看都不看他們的代碼，直接Challenge...然後就失敗了，不敢再亂來了赫赫。
  
  題目意思是說兩個字符串A，B。A，B互相映射，約束就是B中的字母與A中的字母必須一一對應，不能出現一對多的關係以及多對多的關係。問題是給定兩個字符串，計算出需要的最小改動數，使得A，B互相映射。
  
  我的做法就是將A中涉及的字母全部統計出來(vOrder記錄)，以及記錄它們的總數(tot[])並且把A中字母對應到B的映射字母也做一個關聯記錄(record[][]記錄)。對vOrder做全排列(next_permutation)，然後記錄每次全排列時按照此次排列順序獲得的改動數，所有排列遍歷完後，即可得出最小排列數。
  
  因爲題目字母種類少(才10種，A-I)，所以可以大膽放心的使用全排列。如果n=100, O(n!)可是需要10^142 年才能完成全排列…

- YetAnotherTwoTeamsProblem

  我發現Div2真的超愛用DP類型作爲難題，想錯了就瞎，想對了編碼不要太快太短。
  
  題意是給你n個小夥伴，讓你組成A，B兩隊，每個小夥伴的強弱不同，約束條件爲SumSkills(A) > SumSkills(B) and SumSkills(A) - MostWeakGuyInA < SumSkills(B) + MostWeakGuyInA。
  
  開一個小夥伴Skill總和大小的數組dp[]，並將dp[0] = 1。將小夥伴Skills數組降序排列，Skill從最大開始遍歷，dp則從Skill總數開始往下走，dp[j] += dp[j-Skill[i]]，即可獲得所有的分組組合情況。再用上述兩個約束篩選出符合條件的組合，累加即可獲得答案。DP就是如此妙不可言，以空間換取時間。
  
[看SRM591的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM591)


###SRM590 2013/09/07

2013/09/15 update

這場比賽過了兩題，分數漲了150+。500分的題目因爲不自信多交了一次，損失了一些分數。所以本來等級顏色有望變綠的。1000分的題目因爲最近工作太忙，所以拖到這個週末才做出來。及時更新一下，SRM591又要開始了。

- FoxAndGomoku

  五子棋，橫着，豎着，左斜和右斜，4種判斷一遍就好了。
  
- FoxAndGo

  又是地圖搜索類的題目。類似圍棋，問你再多下一顆子的情況下，如何圍殺最多的對方棋子。我用dfs查出來所有的能用一個棋子圍殺的對方棋子堆，記錄下來能圍殺的數量以及落子的位置，因爲可能同一顆落子會圍殺很多塊不同堆。最後合併同一顆落子圍殺的數量，取出最優解。
  
  過程中注意，每次dfs落子的時候，也要標記落子的位置，這樣就不會重複計算這顆落子了。還好Sample 4就是說這個點，不然我的System Test就挂了。

- FoxAndShogi

  這題在一週以後終於被我做出來了。卒和兵，上下移動，問有多少種。注意有可能是多個卒和多個兵。並且數據會很大，要取模。
  
  剛開始的時候是想着排列組合的。但是因爲情況太複雜了，每個卒和兵的位置以及布點都會互相影響。所以最後還是有了dp。dp[i][N]代表第i个士兵在N个点能活动的范围。然后第i个士兵和第i-1个士兵组成的组合可以很自然的变成dp[i][N] = SUM(dp[i-1][1...N-1])这样就可以有个方程式，前k个士兵的组合数量就是SUM(dp[k][1...N-1])就可以算出答案了。注意的是大数取模，要在每一次四则运算中带入，并且在能用加法的时候就不要用乘法了，因为两个大数相乘的时候还是很容易越界溢出来不及取模的。
  
[看SRM590的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM590)


###SRM589 2013/08/27

2013/09/05 update

因爲是晚上七點鐘比賽，我以爲吃個飯回來再註冊還來得及，結果就錯過了。然後我就補做了一下。

- GooseTattarrattatDiv2:

  手快分高。

- GearsDiv2:

  這題剛開始我也是想用dp的。但是數據範圍很小，我就沒有再想下去了。解決方案就是模擬它，但注意模擬時要分別以每個齒輪作爲起點遍歷一遍，因爲它是個環，並且排練先後會影響到策略。

- FlippingBitsDiv2:

  這道題目真的很帥。因爲是說如何按照規則在最小次數的情況下把二進制串變成純1的，我剛開始是想着搜索，並且還很正常的想了兩個減枝策略：1.超過當前最小答案的次數就不要繼續搜索下去。2.記錄搜索過的二進制串以及到達這個二進制串所需要的次數，如果再次出現這個二進制串並且次數大於記錄的，也不用繼續搜索下去。理論貌似是正確的。但是2500的長度，不減枝的搜索空間是2^2500 好嗎操。並且我還真的興致勃勃的寫了一把，結果在用set<T>裝搜索過的10位二進制串的時候，已經爆了居然。XCode不是很會用也不知道是哪裏被操到了。
  
  然後我就琢磨着用dp做了。真是萬能的dp，爲啥都圍繞着dp出題呢。我想了兩天也沒想到完美的解決辦法。然後就Google了。然後就看了一些神經兮兮的解法。歸納如下:
  
  a).因爲有M做誒因素的左右兩頭反轉，所以可以把一個串以M爲倍數做切割，所以可以得到一個k = SIZE/M，然後times[1]，times[2]直到times[k]這樣。因爲上面的分組對一個個翻的模式沒有影響，所以就可以同時組合這兩類操作了。
  
  b).那麼翻的策略是如何呢？其實可以總結爲兩種，I要麼就是一個個將0全部翻爲1。II要麼就是將1全部範圍0後，再用個大反轉，將全0翻爲全1。其他的組合策略一定弱於這兩種，所以只要關心這兩種操作就可以了。
  
  c).當在非times[1]和times[k]對2~(k-1)組反轉的時候，因爲是處於中部的，要考慮前面的times，因爲前面的times相當於都是局部的全1，所以在做這段times的時候，要麼就是把這段裏的0全部轉爲1。要麼就是將這段的1變化爲0，然後對前面的times做全1反轉爲0的操作，再把這兩端一起做全0轉化爲1的操作。也就是times[k]中1的數量(需要反轉爲0),再加兩次全反轉動作。
  
  d).當是times[1]或者times[k]時，因爲一個沒前，一個有後(就是可以從後做全翻的動作)，所以1變0後，再做一次全反轉就可以了。
  
  e).要注意的是我說的times[X]是由2段組成的，而這兩端不一定就是times[X-1]與times[X]，而是由前面所有的段的組合。怎麼描述呢真頭痛。比如說是可以分成4段。那麼times[3] = times[1] + (M+1到3M串)的情況，或者也可能是times[2] + (當前2M+1到3M)的串的情況。兩個M括弧就是我代碼裏的cumul數組相關的表達式。
  
  真是太難表達了。還是看代碼吧。裏面那段我寫的非常蹩腳英文說明以及錯誤很多但意思到了的分段函數好好看一下就會好理解一點了。本來想用中文平易近人的解釋一下方案的，結果發現怎麼表達都不如寫程序來的順暢啊誒。

[看SRM589的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM589)

###SRM588 2013/08/12

房間裏只有壹人解出兩題。我只做出壹題。略難，加上手太生不夠麻利。卡在第二題，對我來說第三題其實更容易得手。

- KeyDungeonDiv2: 
  
  送分题，在此不表。
- GUMIAndSongsDiv2:

   這道題目有點意思，壹直想著用背包(DP)，但是由于前後選擇有依賴，相當于是有狀態的，所以不知如何下手。比賽結束後嘗試用dfs搜索的辦法，把所有的狀態枚舉搜索了壹遍，答案是正確的，但是過不了系統測試，超時了。本想剪枝優化壹下，但是除了歌的長度(duration)還有歌曲音調(tone)變化限制，剪枝未遂。後面看了壹些建議：從songs中，取出兩首的tone作爲上下限(上下限界定完，這樣在這個界限中的切歌最優耗費壹定是MaxTone-MinTone)，再篩選出所有符合這個上下限的歌按duration從小到大排序(貪心在這裏是ok的，因爲在規定時間內，歌曲越多越好)，算出給定時間在這個tone界限中能放的歌曲，最後對比所有組合，取最大。時間複雜度爲O(n^3)。
   
   PS: 比賽時我在的房間只有壹個人最後成功了，而且還是暴力破解，枚舉所有情況的。在進行系統測試時，壹個來自天朝的少年nickname爲"China_xijingping"的還在叫囂說"Brute force is cheating , it can not pass"之類的話，然後那個人就華麗麗麗的pass了…當時我覺得丟人丟到國外的感覺。

- GameInDarknessDiv2:

  這道題其實也比較容易，用bfs或者dfs可以輕松搞定。只要明白Alice的下壹步以及Alice當前壹步，都需要考慮，這樣Bob才不會跟Alice撞到壹起。先把Alice的移動全部標記到壹個狀態數組[step][y][x]，後續Bob每次進行dfs的時候，就可以對比Alice狀態數組，同時記錄Bob自己的狀態數組[step][y][x]，把第n步移動到[yn][xn]的位置都標記上，以免反複的進行dfs。最後只要Bob能堅挺的完成所有step，那麽Bob就贏了。
  
  這題目就是寫起來比較麻煩。手慢則來不及了。

[看代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM588)

###SRM587 2013/08/01

這場比賽也很慘，本來可以命中三題的，但是第二題用dp沒過系統測試，第三題寫好來不及提交時間就到了。不開心。> <

- InsertZ : 這題考驗智力水平是不是適合當程序員。
- JumpFurther :

  這題我當時想用dp做，還華麗的寫出了個狀態轉移方程。但是系統測試證明我是錯的。其實是一個數學公式。能達到的總數是一定的，只要某段求和爲badstep，則可以總數減一繞過去。否則返回總數。我討厭數學，真的。

- ThreeColorabilityEasy :

  也是數學題，只要4個組合成的矩形構成不是3:1的情況就Yes，否則爲No。
  
[看代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM587)
   
   

