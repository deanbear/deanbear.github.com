---
layout: post
title: TopCoder竞赛笔记
date: 2013-08-18 17:11:59
categories:
- 技术流/techgangster 
tags:
- TopCoder
- Programming
- algorithm
---
讀書的時候，在NIT埋頭搞了一年多的ACM，後面轉學了，到ZJUT的時候又稍微玩了個把月拿了個校一等獎就去實習了，後面的兩年就沒再接觸過編程競賽了。今年搬家和新室友住一起，其中一個是ACMer，參加過WorldFinal，工作之後還有在堅持玩競賽。所以我這把年紀才開始玩TopCoder就是由他帶起的。

讀書的時候也有聽說TopCoder，並且伴着許多傳說，比如“XXX在上面贏了XX萬美刀的獎金”，“XXX憑着TopCoder的成績拿了多少多少萬年薪”之類的。當然，每個行業都有這樣的天才人物。我這種小脆皮根本和這樣的傳說搭不上邊，當然沒有啥好說的。但既然上了這條賊船，讓自己變的更強大也是理所應當的。這樣也表明自己弱雖弱，但有一顆上進的心嘛。並且做做編程算法是肯定有好處的，因爲編程本身就是另外一種思考方式。

TopCoder的賽制啊判分標準之類的我還不熟，待以後玩利落了再來八一八。現在一個月2-3次的比賽，一场2小时左右(SRM,Single Round Match)，頻率和时间還是很适合大部分工作了的程序员的。我現在還在Division 2，也就是菜鳥的範疇中，努力升級至Div1中> <

我在Topcoder上寫過的代碼都會託管在github上，[點擊這](https://github.com/deanbear/TopCoder)。並且在這篇文章會定期更新代碼思路。

Get fun from programming. May the force be with you.

***

###SRM589 2013/08/27

2013/09/05 update

因爲是晚上七點鐘比賽，我以爲吃個飯回來再註冊還來得及，結果就錯過了。然後我就補做了一下。

- GooseTattarrattatDiv2:

  手快分高。

- GearsDiv2:

  這題剛開始我也是想用dp的。但是數據範圍很小，我就沒有再想下去了。解決方案就是模擬它，但注意模擬時要分別以每個齒輪作爲起點遍歷一遍，因爲它是個環，並且排練先後會影響到策略。

- FlippingBitsDiv2:

  這道題目真的很帥。因爲是說如何按照規則在最小次數的情況下把二進制串變成純1的，我剛開始是想着搜索，並且還很正常的想了兩個減枝策略：1.超過當前最小答案的次數就不要繼續搜索下去。2.記錄搜索過的二進制串以及到達這個二進制串所需要的次數，如果再次出現這個二進制串並且次數大於記錄的，也不用繼續搜索下去。理論貌似是正確的。但是2500的長度，不減枝的搜索空間是2^2500好嗎操。並且我還真的興致勃勃的寫了一把，結果在用set<T>裝搜索過的10位二進制串的時候，已經爆了居然。XCode不是很會用也不知道是哪裏被操到了。
  
  然後我就琢磨着用dp做了。真是萬能的dp，爲啥都圍繞着dp出題呢。我想了兩天也沒想到完美的解決辦法。然後就Google了。然後就看了一些神經兮兮的解法。歸納如下:
  
  a).因爲有M做誒因素的左右兩頭反轉，所以可以把一個串以M爲倍數做切割，所以可以得到一個k = SIZE/M，然後times[1]，times[2]直到times[k]這樣。因爲上面的分組對一個個翻的模式沒有影響，所以就可以同時組合這兩類操作了。
  
  b).那麼翻的策略是如何呢？其實可以總結爲兩種，I要麼就是一個個將0全部翻爲1。II要麼就是將1全部範圍0後，再用個大反轉，將全0翻爲全1。其他的組合策略一定弱於這兩種，所以只要關心這兩種操作就可以了。
  
  c).當在非times[1]和times[k]對2~(k-1)組反轉的時候，因爲是處於中部的，要考慮前面的times，因爲前面的times相當於都是局部的全1，所以在做這段times的時候，要麼就是把這段裏的0全部轉爲1。要麼就是將這段的1變化爲0，然後對前面的times做全1反轉爲0的操作，再把這兩端一起做全0轉化爲1的操作。也就是times[k]中1的數量(需要反轉爲0),再加兩次全反轉動作。
  
  d).當是times[1]或者times[k]時，因爲一個沒前，一個有後(就是可以從後做全翻的動作)，所以1變0後，再做一次全反轉就可以了。
  
  e).要注意的是我說的times[X]是由2段組成的，而這兩端不一定就是times[X-1]與times[X]，而是由前面所有的段的組合。怎麼描述呢真頭痛。比如說是可以分成4段。那麼times[3] = times[1] + (M+1到3M串)的情況，或者也可能是times[2] + (當前2M+1到3M)的串的情況。兩個M括弧就是我代碼裏的cumul數組相關的表達式。
  
  真是太難表達了。還是看代碼吧。裏面那段我寫的非常蹩腳英文說明以及錯誤很多但意思到了的分段函數好好看一下就會好理解一點了。本來想用中文平易近人的解釋一下方案的，結果發現怎麼表達都不如寫程序來的順暢啊誒。

[看SRM589的代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM589)

###SRM588 2013/08/12

房間裏只有壹人解出兩題。我只做出壹題。略難，加上手太生不夠麻利。卡在第二題，對我來說第三題其實更容易得手。

- KeyDungeonDiv2: 
  
  送分题，在此不表。
- GUMIAndSongsDiv2:

   這道題目有點意思，壹直想著用背包(DP)，但是由于前後選擇有依賴，相當于是有狀態的，所以不知如何下手。比賽結束後嘗試用dfs搜索的辦法，把所有的狀態枚舉搜索了壹遍，答案是正確的，但是過不了系統測試，超時了。本想剪枝優化壹下，但是除了歌的長度(duration)還有歌曲音調(tone)變化限制，剪枝未遂。後面看了壹些建議：從songs中，取出兩首的tone作爲上下限(上下限界定完，這樣在這個界限中的切歌最優耗費壹定是MaxTone-MinTone)，再篩選出所有符合這個上下限的歌按duration從小到大排序(貪心在這裏是ok的，因爲在規定時間內，歌曲越多越好)，算出給定時間在這個tone界限中能放的歌曲，最後對比所有組合，取最大。時間複雜度爲O(n^3)。
   
   PS: 比賽時我在的房間只有壹個人最後成功了，而且還是暴力破解，枚舉所有情況的。在進行系統測試時，壹個來自天朝的少年nickname爲"China_xijingping"的還在叫囂說"Brute force is cheating , it can not pass"之類的話，然後那個人就華麗麗麗的pass了…當時我覺得丟人丟到國外的感覺。

- GameInDarknessDiv2:

  這道題其實也比較容易，用bfs或者dfs可以輕松搞定。只要明白Alice的下壹步以及Alice當前壹步，都需要考慮，這樣Bob才不會跟Alice撞到壹起。先把Alice的移動全部標記到壹個狀態數組[step][y][x]，後續Bob每次進行dfs的時候，就可以對比Alice狀態數組，同時記錄Bob自己的狀態數組[step][y][x]，把第n步移動到[yn][xn]的位置都標記上，以免反複的進行dfs。最後只要Bob能堅挺的完成所有step，那麽Bob就贏了。
  
  這題目就是寫起來比較麻煩。手慢則來不及了。

[看代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM588)

###SRM587 2013/08/01

這場比賽也很慘，本來可以命中三題的，但是第二題用dp沒過系統測試，第三題寫好來不及提交時間就到了。不開心。> <

- InsertZ : 這題考驗智力水平是不是適合當程序員。
- JumpFurther :

  這題我當時想用dp做，還華麗的寫出了個狀態轉移方程。但是系統測試證明我是錯的。其實是一個數學公式。能達到的總數是一定的，只要某段求和爲badstep，則可以總數減一繞過去。否則返回總數。我討厭數學，真的。

- ThreeColorabilityEasy :

  也是數學題，只要4個組合成的矩形構成不是3:1的情況就Yes，否則爲No。
  
[看代碼點擊我](https://github.com/deanbear/TopCoder/tree/master/SRM/SRM587)
   
   

