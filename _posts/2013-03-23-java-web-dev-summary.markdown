---
author: Bear
comments: true
date: 2013-03-23 17:10:35
layout: post
slug: java-web-dev-summary
title: Java Web 开发总结
wordpress_id: 126
categories:
- 开发那些事儿
tags:
- Java
---

最近在做迁移，将用了好几年的几个接口从公共应用中剥离出来，迁移至自己团队的应用中。因为公共应用历史悠久，人多手杂，代码重新编写也花了些时间，也顺手将工作一年以来的一些开发经验写了一遍。由于涉及到很多都是和公司整个技术体系架构有关的，可能属于特殊衍生，也不算是普遍J2EE经验吧。而且不保证是正确的，仅个人现阶段经验，凑巧看到觉得哪里不对，就帮我指出订正一把，谢啦。
<!-- more -->


> {二方包依赖}

利用Maven POM来管理依赖包。在根目录的pom.xml中<dependencyManagement>增加需要依赖的包的<artifactId>，<groupId>，<version>信息，再到需要此依赖包的子模块的pom(web/pom.xml或biz/pom.xml)中的<dependencies>增加依赖包的<artifactId>以及<groupId>即可。注意web/pom.xml是依赖biz/pom.xml的，所以如果biz和web都需要此依赖包，只需要写在biz/pom.xml就可以。

添加完毕后还需要检验Jar包冲突，因为我们一系列作为前端应用会依赖数量惊人的二方包以及二方包所依赖的间接依赖，往往因为间接依赖的Jar包版本不同导致冲突在线上部署时会有一定机率产生错误，后果很严重。常规手段: 在应用文件夹根目录命令行输入mvn dependency:tree > check.txt ，可在check.txt中查看是新增的依赖包的间接依赖是否与其他依赖包的间接依赖存在名字相同版本号不同的情况。有则需要用<exclusion>排除版本较旧的依赖包。黑体强调：

**不要忘记在新增依赖后检查Jar包冲突，不然会变冤大头。**

{应用配置项}

由于有2套不同的开发环境，日常(daily)，预发(prepub)，以及一个正式的线上(online)生产环境，所以不同的环境有不同的域名，类目等参数配置。专门用到了配置项，在不同的环境配置不同的值。配置项相关的两个文件antx.properties，auto-config.xml。简单易懂不多说。黑体强调：

**处理在不同环境有不同值的配置常量时，用配置项稳妥安全。**

{常量类与开关类}

在代码中会用到很多常量，例如商品属性标记，缓存命名空间编号等。基本都有对应的常量类(*Constants.java)，写入静态变量。在业务上线需要考虑其用户体验，功能缺陷以及与其他应用衔接不上时，可以采用开关做优雅降级。具体可参见*Switch*.java类以及对应控制开关的*switch*.jsp。黑体强调：

**不要将常量做硬编码处理。业务有风险增加开关。**

{逻辑分层}

一般情况下应用分成表现层，业务层，持久层。各层各司其职，互不侵犯，在完成本层相应功能，通过接口以及相应数据类进行通信。分层的本质就是为了保证各块逻辑功能不耦合在一起，方便应用扩展以及维护，杜绝了牵一发而动全身的开发过程。当然，在业务变化略大的情况下，还是必须至上而下的每层都做出调整，这是因为业务作为一切存在的核心与关键点，就是这么无可厚非。

Malldetail系列作为最前端最直接与用户交互的应用，出于性能考虑，去掉了持久层，即不与数据库直连。所以在Malldetail系列中只需要关注表现层与业务层，即应用中的Web层与Biz层。以下建议尽量遵循，因为完美的理想状态是根本不存在的。

(a)Web层

Web层又主要可分为两块，在阿里巴巴的Webx框架中，Module类(Screen or Control)与其对应的Velocity模板。

Module类功能限定：

1)管理请求，响应[Request & Response]

2)提供封装解析给业务层接口的参数[Params & session info]

3)调用Biz层业务接口以及组装处理接口返回数据对象或异常流

4)一些请求监控记录日志

VM模板功能限定:

1)页面布局

2)纯数据展现(理想状态，很难，以及部分逻辑处理还是不可避免的，可以理解)

在Web层中强调后端Java类不应过分与业务逻辑耦合，理想状态只做业务接口调用以及业务参数组装的工作。唯一的明确要求，黑体强调:

**不要在Web层做与业务逻辑相关的编码，放到Biz层去做。Web层展现出来的代码必须是很清爽的只与Web相关的一个Module类。**

(b)Biz层

在Malldetail系列中，Biz层承上(Web层)启下(各基础C应用)顾左右(其他平行应用)。基本可以做以下逻辑封装:AO->Manager->Service Client。Service Client即HSF(RPC)调用的接口，类似于DAO层调用但是远程我们并不关心其实现。

这三种类层层包裹的意义在于:

1)结构清晰，易于理解。

Manager关心对应ServiceClient的响应结果处理，AO则是顾全整条业务获取的逻辑。在后续维护修改时能很容易找到对应的修改点。

2)弱耦合，弱依赖。

这和三层模式类似，Web层依赖Biz层，Biz层对Web层是无知的，只提供数据不管展现。改变展现对数据提供没有影响。同样，修改AO类内容对Manager也无影响。同时由于采用面向接口设计模式(IOC) ，使得AO对于Web层，Manager对于AO，在不改变接口定义的前提下，支持抽取，替换，如同抽屉。

正因为如此，业务逻辑层的设计对于一个支持可扩展的架构尤为关键，因为它扮演了两个不同的角色。对于数据访问层而言，它是调用者；对于表现层而言，它却是被调用者。

业务层的功能如下:

I   处理应用的业务逻辑和业务校验

II  允许与其他层进行交互的接口

III 管理业务级对象之间的依赖性

IV 增加了表现和持久层之间的灵活性，不需要彼此进行直接通信

在Biz层强调业务逻辑的处理，要求黑体强调：

**以一致的AO->Manager->ServiceClient方式封装处理，面对接口编程，也不要把Web层的东西(例如Request，Response，Context等)带入到业务层。**

{数据流通}

这里说的数据流通就是以怎样统一形式的类对象作为载体，贯穿从请求的进入到Web再到Biz的查询以及到远程调用的数据处理。一般来说，过程如下：

1> 在Web层将参数以及一些需要的数据拼装成*Query对象，传递给调用AO接口查询。

2> AO或Manager中再提取Query对象拼装远程调用所规定的Query类型的DO，远程调用。

3> 返回Result对象，判断返回成功异常流等，若是由调用应用提供的对象DO，则直接返回，若是自己拼装的数据集，则需要保留一个中间状态的Result，当作此接口调用稳定的中间态数据返回，方便其他应用调用(如无线的同学可能会用到接口返回数据，所以保留一个大家能通用的中间结果数据类)。

4> 在AO或Manager中将返回的结果数据处理成DO类，有两种处理方式1)toJson处理后以JSON格式供给前端同学使用，2)或者set回到指定Query中再放入context，在vm模板上使用。

当然如果结果数据很简单，就不用费力做这么多转化。还有就是中间态的数据往往是结果数据的超集，内容更丰富更透明，结果数据给自己，中间态数据给大家。简要的说，黑体强调：

**查询数据Query，中间态的返回数据Result，结果数据DO。**

{异步结构编码}

出于对前端服务高响应高并发的性能要求，系统由单个拆分成系列。主系统负责主请求响应以及页面静态化缓存，辅系统负责浏览器异步加载的API接口调用，后台系统负责管理静态化缓存。所以在涉及业务代码编写时，基本涉及到的会是主以及辅两个应用。业务代码该在哪个应用实现的准则是这样约定的：与商品相关的，在主系统处理，因为主系统会对详情页面做静态化存储某个时长(1小时)，因为商品信息实时性质不强，只是在商家编辑时会改变，所以将商品信息相关的数据放在页面上同时缓存起来，当商家编辑宝贝触发数据库修改时，应用会接到商品中心发的消息，自动清除该商品缓存内容，再在下一次请求中缓存最新的商品信息。而与登录用户以及实时性要求较高的(如库存，限时优惠等)内容，则在辅系统处理，这样能针对特定用户实现特定逻辑以及返回准确的与购买相关的最新数据。黑体强调：

**与商品信息相关的业务逻辑在主系统搞定，实时性要求强以及与登录用户相关的业务逻辑写在辅系统。**

{组合or继承}

虽然面向对象的特征之一就是继承机制，但是除非是你能看出继承机制对你的编码带来了明显的好处，还是尽量用组合的形式，因为它更加灵活方便，适应于业务的组合与变化。一个很好的标准用来判断用组合还是用编码：是否有必要向上转型(Do I need to upcast?)。如果有这种场景，则用继承，若没有，用组合就好。黑体强调一下：

**组合优先于继承，除非你有很大的把握同时还有向上转型的场景等着你。**

{约定胜于配置}

Maven做了应用目录的约定(src/main/java , src/test/java等目录结构)，Webx框架做了URL转化target，target查找执行对应模块Module类以及渲染对应VM模板以的约定。按照约定进行编码，这样省去了很多配置的麻烦。

**约定胜于配置，妈妈再也不担心我的流程结构规范了。**

{依赖注入及其XML配置}

依赖注入建议使用annotation注释方式，省去setter方法，让开发高效，代码简洁。同时建议使用@Resource来进行注入注释。因为@Resource出自JSR-250规范，是在J2EE层面的annotation，而@Autowired只是Spring层面的annotation。同时它默认采用byName来查找注入bean，而@Autowired默认采用byType的。两种方式在效率上还是有区别的，但由于实例基本都是Singleton的，所以只在启动时有差而在运行时不存在开销区别。

bean的xml建议:按照接入应用Client包配置对应xml，以xx-client.xml规范命名。本地业务bean则以后缀归类写入对应xml。如manager.xml，ao.xml。这样即可方便后续维护查找修改。黑体强调：

**@Resource注入高端大气上档次，XML分门别类好管理。**
