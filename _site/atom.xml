<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>熊迪恩</title>
 <link href="http://deanbear.github.com/" rel="self"/>
 <link href="http://deanbear.github.com"/>
 <updated>2013-04-17T17:32:55+08:00</updated>
 <id>http://deanbear.github.com</id>
 <author>
   <name>dean bear</name>
   <email>deanbear1990@gmail.com</email>
 </author>

 
 <entry>
   <title>不是你运气不好，而是你没买彩票</title>
   <link href="http://deanbear.github.com/2013/03/24/make-your-own-luck-idio"/>
   <updated>2013-03-24T04:40:50+08:00</updated>
   <id>http://deanbear.github.com/2013/03/24/make-your-own-luck-idio</id>
   <content type="html">&lt;p&gt;3月过的很不开心。我觉得吧，很久没有这样衰神附体了。好吧那就这样，我命名2013年3月是&quot;要衰，就衰的更猛烈些吧&quot;月。明天拖了2个月(诶买把吉他都2个月的等待这么衰你看看)的Martin DRS1终于漂洋过海要到我手上，所以大概没时间写了，下周就肉身翻墙了，再回来的时候就4月了。先把男默女泪，听者伤心闻者流泪的剧情写掉，然后抹一把心酸泪，把坏运气都丢在太平洋，再来个背影超帅的逆转大结局。&lt;/p&gt;

&lt;p&gt;…哈哈哈忍不住了开玩笑，其实也没有很可怜，我只是在用了夸张的修辞手法。说两个事儿吧。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;&lt;p&gt;驾照考试，场考挂了。现在还在等重考通知。这真是件很丢人的事情，非常没有面子，简直可以写在我人生耻辱柱上前三甲了诶。挂的原因用膝盖也想的出来:我这种天生自大狂总是会因为自以为是的骄傲得意到无以复加吃亏吃到死不悔改好了伤疤忘了疼。男人，就觉得机械，钢铁，发动机很帅，车刚好满足了这样的一种心理，特别一坐到驾驶位，我都是用驾照黄金之心宇宙飞船(详见银河系漫游指南)的心来开桑塔纳的，而且还是一档都能开出这感觉...师傅说我以后有钱了可以去开赛车...总之就是我开车很快，因为我觉得车开很慢是一件非常难看的事情...但是现在看来，考驾照挂了才是一件比开车开慢要难看100倍的事情。因为练车时都开的很快，但是真正到考试了，又不敢快起来，结果就节奏各种不对，顺其自然就挂了唉。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这个故事告诉我们：自以为是的人只能吃屎了...唉。慢慢来，比较快。下次我肯定会缓缓的，非常成熟稳重的，把这件事完成。所以沉稳内敛的人虽然没有意气风发的人那么耀眼，但是，值得信赖与托付的往往是前者吧。快点成熟起来吧，已经过了当意气风发少年的时间了，还有很长的路要走。&lt;/p&gt;

&lt;p&gt;II.
去年的绩效，只拿了一个中等偏上。以为能破格晋升，最后还是因为考评中等偏上黄了。所以3月上半旬很闷，这个原因占了大头。我是好强的人没错，所以有的时候会被挫败感疼到不行。我知道以后还有很多这样的事情会在等我，但是这次我心里真的很不服气。我觉得去年我真的有很上进很努力的在把工作当成事业来做，好吧虽然我自我感觉一贯这么良好…没有被认同是很糟糕的体验。认同感和成就感很像，一个是别人给予的，一个是自我感觉。结果我去年的成就感和别人给的认同感就没有对上等号。刚得到结果的那几天很气馁，虽然表现的还是大大咧咧的，其实这种事当然会不开心啊。然后熊爸又教育了我熊妈又安慰了我，睡了几觉就好起来了。然后刚好看到@caoz的话...然后我就有点羞愧了，确实我当时就是这么白痴的想法，被对号入座了。然后听了几首摇滚后我这种死小孩的斗志又被点燃了。不够好，那我只好做的更好。一直努力，一直努力，一直努力，然后赢。&lt;/p&gt;

&lt;p&gt;这个故事告诉我们：蔡文胜和曹政是一伙的!!!…他们两原话是这样的： &quot;@caoz:我发现很多牛b的朋友，成功的时候说自己运气好，失败的时候说自己能力不足；当然，更多是相反的人。 请对号入座！// @蔡文胜：衡量一个人是否成熟进步的标准：碰到挫折失败的时候，首先反省自己的错误与不足，而不是指责别人与抱怨运气！&quot; &lt;a href=&quot;http://goo.gl/hfqJO&quot;&gt;原地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;End
故事就说到这儿。当然还有其他的事，但是我不开心说。咽下去的故事多了就成了有故事的人了。
&quot;I will fight, and I‘ll sleep when I die, I'll live my life, I'm Alive!&quot; -- Becca , I'm Alive&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java Web 开发总结</title>
   <link href="http://deanbear.github.com/2013/03/24/java-web-dev-summary"/>
   <updated>2013-03-24T01:10:35+08:00</updated>
   <id>http://deanbear.github.com/2013/03/24/java-web-dev-summary</id>
   <content type="html">&lt;p&gt;最近在做迁移，将用了好几年的几个接口从公共应用中剥离出来，迁移至自己团队的应用中。因为公共应用历史悠久，人多手杂，代码重新编写也花了些时间，也顺手将工作一年以来的一些开发经验写了一遍。由于涉及到很多都是和公司整个技术体系架构有关的，可能属于特殊衍生，也不算是普遍J2EE经验吧。而且不保证是正确的，仅个人现阶段经验，凑巧看到觉得哪里不对，就帮我指出订正一把，谢啦。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;blockquote&gt;&lt;p&gt;{二方包依赖}&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;利用Maven POM来管理依赖包。在根目录的pom.xml中&lt;dependencyManagement&gt;增加需要依赖的包的&lt;artifactId&gt;，&lt;groupId&gt;，&lt;version&gt;信息，再到需要此依赖包的子模块的pom(web/pom.xml或biz/pom.xml)中的&lt;dependencies&gt;增加依赖包的&lt;artifactId&gt;以及&lt;groupId&gt;即可。注意web/pom.xml是依赖biz/pom.xml的，所以如果biz和web都需要此依赖包，只需要写在biz/pom.xml就可以。&lt;/p&gt;

&lt;p&gt;添加完毕后还需要检验Jar包冲突，因为我们一系列作为前端应用会依赖数量惊人的二方包以及二方包所依赖的间接依赖，往往因为间接依赖的Jar包版本不同导致冲突在线上部署时会有一定机率产生错误，后果很严重。常规手段: 在应用文件夹根目录命令行输入mvn dependency:tree &gt; check.txt ，可在check.txt中查看是新增的依赖包的间接依赖是否与其他依赖包的间接依赖存在名字相同版本号不同的情况。有则需要用&lt;exclusion&gt;排除版本较旧的依赖包。黑体强调：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要忘记在新增依赖后检查Jar包冲突，不然会变冤大头。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{应用配置项}&lt;/p&gt;

&lt;p&gt;由于有2套不同的开发环境，日常(daily)，预发(prepub)，以及一个正式的线上(online)生产环境，所以不同的环境有不同的域名，类目等参数配置。专门用到了配置项，在不同的环境配置不同的值。配置项相关的两个文件antx.properties，auto-config.xml。简单易懂不多说。黑体强调：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;处理在不同环境有不同值的配置常量时，用配置项稳妥安全。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{常量类与开关类}&lt;/p&gt;

&lt;p&gt;在代码中会用到很多常量，例如商品属性标记，缓存命名空间编号等。基本都有对应的常量类(&lt;em&gt;Constants.java)，写入静态变量。在业务上线需要考虑其用户体验，功能缺陷以及与其他应用衔接不上时，可以采用开关做优雅降级。具体可参见&lt;/em&gt;Switch&lt;em&gt;.java类以及对应控制开关的&lt;/em&gt;switch*.jsp。黑体强调：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要将常量做硬编码处理。业务有风险增加开关。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{逻辑分层}&lt;/p&gt;

&lt;p&gt;一般情况下应用分成表现层，业务层，持久层。各层各司其职，互不侵犯，在完成本层相应功能，通过接口以及相应数据类进行通信。分层的本质就是为了保证各块逻辑功能不耦合在一起，方便应用扩展以及维护，杜绝了牵一发而动全身的开发过程。当然，在业务变化略大的情况下，还是必须至上而下的每层都做出调整，这是因为业务作为一切存在的核心与关键点，就是这么无可厚非。&lt;/p&gt;

&lt;p&gt;Malldetail系列作为最前端最直接与用户交互的应用，出于性能考虑，去掉了持久层，即不与数据库直连。所以在Malldetail系列中只需要关注表现层与业务层，即应用中的Web层与Biz层。以下建议尽量遵循，因为完美的理想状态是根本不存在的。&lt;/p&gt;

&lt;p&gt;(a)Web层&lt;/p&gt;

&lt;p&gt;Web层又主要可分为两块，在阿里巴巴的Webx框架中，Module类(Screen or Control)与其对应的Velocity模板。&lt;/p&gt;

&lt;p&gt;Module类功能限定：&lt;/p&gt;

&lt;p&gt;1)管理请求，响应[Request &amp;amp; Response]&lt;/p&gt;

&lt;p&gt;2)提供封装解析给业务层接口的参数[Params &amp;amp; session info]&lt;/p&gt;

&lt;p&gt;3)调用Biz层业务接口以及组装处理接口返回数据对象或异常流&lt;/p&gt;

&lt;p&gt;4)一些请求监控记录日志&lt;/p&gt;

&lt;p&gt;VM模板功能限定:&lt;/p&gt;

&lt;p&gt;1)页面布局&lt;/p&gt;

&lt;p&gt;2)纯数据展现(理想状态，很难，以及部分逻辑处理还是不可避免的，可以理解)&lt;/p&gt;

&lt;p&gt;在Web层中强调后端Java类不应过分与业务逻辑耦合，理想状态只做业务接口调用以及业务参数组装的工作。唯一的明确要求，黑体强调:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要在Web层做与业务逻辑相关的编码，放到Biz层去做。Web层展现出来的代码必须是很清爽的只与Web相关的一个Module类。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(b)Biz层&lt;/p&gt;

&lt;p&gt;在Malldetail系列中，Biz层承上(Web层)启下(各基础C应用)顾左右(其他平行应用)。基本可以做以下逻辑封装:AO-&gt;Manager-&gt;Service Client。Service Client即HSF(RPC)调用的接口，类似于DAO层调用但是远程我们并不关心其实现。&lt;/p&gt;

&lt;p&gt;这三种类层层包裹的意义在于:&lt;/p&gt;

&lt;p&gt;1)结构清晰，易于理解。&lt;/p&gt;

&lt;p&gt;Manager关心对应ServiceClient的响应结果处理，AO则是顾全整条业务获取的逻辑。在后续维护修改时能很容易找到对应的修改点。&lt;/p&gt;

&lt;p&gt;2)弱耦合，弱依赖。&lt;/p&gt;

&lt;p&gt;这和三层模式类似，Web层依赖Biz层，Biz层对Web层是无知的，只提供数据不管展现。改变展现对数据提供没有影响。同样，修改AO类内容对Manager也无影响。同时由于采用面向接口设计模式(IOC) ，使得AO对于Web层，Manager对于AO，在不改变接口定义的前提下，支持抽取，替换，如同抽屉。&lt;/p&gt;

&lt;p&gt;正因为如此，业务逻辑层的设计对于一个支持可扩展的架构尤为关键，因为它扮演了两个不同的角色。对于数据访问层而言，它是调用者；对于表现层而言，它却是被调用者。&lt;/p&gt;

&lt;p&gt;业务层的功能如下:&lt;/p&gt;

&lt;p&gt;I   处理应用的业务逻辑和业务校验&lt;/p&gt;

&lt;p&gt;II  允许与其他层进行交互的接口&lt;/p&gt;

&lt;p&gt;III 管理业务级对象之间的依赖性&lt;/p&gt;

&lt;p&gt;IV 增加了表现和持久层之间的灵活性，不需要彼此进行直接通信&lt;/p&gt;

&lt;p&gt;在Biz层强调业务逻辑的处理，要求黑体强调：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以一致的AO-&gt;Manager-&gt;ServiceClient方式封装处理，面对接口编程，也不要把Web层的东西(例如Request，Response，Context等)带入到业务层。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{数据流通}&lt;/p&gt;

&lt;p&gt;这里说的数据流通就是以怎样统一形式的类对象作为载体，贯穿从请求的进入到Web再到Biz的查询以及到远程调用的数据处理。一般来说，过程如下：&lt;/p&gt;

&lt;p&gt;1&gt; 在Web层将参数以及一些需要的数据拼装成*Query对象，传递给调用AO接口查询。&lt;/p&gt;

&lt;p&gt;2&gt; AO或Manager中再提取Query对象拼装远程调用所规定的Query类型的DO，远程调用。&lt;/p&gt;

&lt;p&gt;3&gt; 返回Result对象，判断返回成功异常流等，若是由调用应用提供的对象DO，则直接返回，若是自己拼装的数据集，则需要保留一个中间状态的Result，当作此接口调用稳定的中间态数据返回，方便其他应用调用(如无线的同学可能会用到接口返回数据，所以保留一个大家能通用的中间结果数据类)。&lt;/p&gt;

&lt;p&gt;4&gt; 在AO或Manager中将返回的结果数据处理成DO类，有两种处理方式1)toJson处理后以JSON格式供给前端同学使用，2)或者set回到指定Query中再放入context，在vm模板上使用。&lt;/p&gt;

&lt;p&gt;当然如果结果数据很简单，就不用费力做这么多转化。还有就是中间态的数据往往是结果数据的超集，内容更丰富更透明，结果数据给自己，中间态数据给大家。简要的说，黑体强调：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查询数据Query，中间态的返回数据Result，结果数据DO。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{异步结构编码}&lt;/p&gt;

&lt;p&gt;出于对前端服务高响应高并发的性能要求，系统由单个拆分成系列。主系统负责主请求响应以及页面静态化缓存，辅系统负责浏览器异步加载的API接口调用，后台系统负责管理静态化缓存。所以在涉及业务代码编写时，基本涉及到的会是主以及辅两个应用。业务代码该在哪个应用实现的准则是这样约定的：与商品相关的，在主系统处理，因为主系统会对详情页面做静态化存储某个时长(1小时)，因为商品信息实时性质不强，只是在商家编辑时会改变，所以将商品信息相关的数据放在页面上同时缓存起来，当商家编辑宝贝触发数据库修改时，应用会接到商品中心发的消息，自动清除该商品缓存内容，再在下一次请求中缓存最新的商品信息。而与登录用户以及实时性要求较高的(如库存，限时优惠等)内容，则在辅系统处理，这样能针对特定用户实现特定逻辑以及返回准确的与购买相关的最新数据。黑体强调：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;与商品信息相关的业务逻辑在主系统搞定，实时性要求强以及与登录用户相关的业务逻辑写在辅系统。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{组合or继承}&lt;/p&gt;

&lt;p&gt;虽然面向对象的特征之一就是继承机制，但是除非是你能看出继承机制对你的编码带来了明显的好处，还是尽量用组合的形式，因为它更加灵活方便，适应于业务的组合与变化。一个很好的标准用来判断用组合还是用编码：是否有必要向上转型(Do I need to upcast?)。如果有这种场景，则用继承，若没有，用组合就好。黑体强调一下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组合优先于继承，除非你有很大的把握同时还有向上转型的场景等着你。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{约定胜于配置}&lt;/p&gt;

&lt;p&gt;Maven做了应用目录的约定(src/main/java , src/test/java等目录结构)，Webx框架做了URL转化target，target查找执行对应模块Module类以及渲染对应VM模板以的约定。按照约定进行编码，这样省去了很多配置的麻烦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;约定胜于配置，妈妈再也不担心我的流程结构规范了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;{依赖注入及其XML配置}&lt;/p&gt;

&lt;p&gt;依赖注入建议使用annotation注释方式，省去setter方法，让开发高效，代码简洁。同时建议使用@Resource来进行注入注释。因为@Resource出自JSR-250规范，是在J2EE层面的annotation，而@Autowired只是Spring层面的annotation。同时它默认采用byName来查找注入bean，而@Autowired默认采用byType的。两种方式在效率上还是有区别的，但由于实例基本都是Singleton的，所以只在启动时有差而在运行时不存在开销区别。&lt;/p&gt;

&lt;p&gt;bean的xml建议:按照接入应用Client包配置对应xml，以xx-client.xml规范命名。本地业务bean则以后缀归类写入对应xml。如manager.xml，ao.xml。这样即可方便后续维护查找修改。黑体强调：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Resource注入高端大气上档次，XML分门别类好管理。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java并发编程笔记-PART II.构建并发应用</title>
   <link href="http://deanbear.github.com/2013/03/13/java-concurrency-in-practice-part-ii-structuring-concurrent-applications"/>
   <updated>2013-03-13T00:37:53+08:00</updated>
   <id>http://deanbear.github.com/2013/03/13/java-concurrency-in-practice-part-ii-structuring-concurrent-applications</id>
   <content type="html">&lt;p&gt;第一部分讲完了并发的一些基础原理，接着开始讲具体怎样构建并发程序。&lt;/p&gt;

&lt;p&gt;Chapter 6. Task Execution&lt;/p&gt;

&lt;p&gt;用多线程代替单个主线程，将任务派发给多个线程执行。带来三个影响点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; 处理任务的工作从主线程脱离出来，使得主线程能更快处理下一个进来的请求。提高响应速度。&lt;/li&gt;
&lt;li&gt; 任务被平行的处理，对多个请求能同时提供服务，在多核处理器或者任务被阻塞时(如IO，锁，资源等待)，会提高性能。&lt;/li&gt;
&lt;li&gt; 任务处理代码必须线程安全，因为可能会并发的被多任务引用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果创建线程无穷无尽，肯定会出现问题，系统资源吃紧。首先创建和销毁线程都需要额外的cpu和内存资源，其次由于cpu核数有效，过多的线程会因为分配时间片的间隔过久导致闲置状态过久，同样消耗内存。第三，会对系统的稳定性造成影响，太多的线程可能会导致OutOfMemoryError，及其冒险。开多少线程能让应用保持最佳的效率性能，是需要评测对比性能测试数据调试到最佳状态。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;顺序执行任务的瓶颈是低效的响应和吞吐量，多线程执行任务的瓶颈是资源管理。
Executor提供了将任务提交从任务执行解藕出来的标准方法，用Runnable描述任务，Executor的实现类提供了生命周期控制，监控等一系列任务管理功能。
Executor是基于生产者-消费者模式的，提交任务的是生产者，线程执行任务则是消费者，用Executor通常是最简单的途径来实现生产者-消费者模式的设计。
任务执行策略有以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; 任务在哪个线程被执行?&lt;/li&gt;
&lt;li&gt; 任务执行顺序是怎样的(FIFO,LIFO,priority order)?&lt;/li&gt;
&lt;li&gt; 多少任务能同时执行?&lt;/li&gt;
&lt;li&gt; 多少任务必须排队执行？&lt;/li&gt;
&lt;li&gt; 当因为系统过载而拒绝一个任务时，拒绝哪个任务，并能被系统知晓?&lt;/li&gt;
&lt;li&gt; 在执行任务前后还需要做哪些动作?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;执行策略是一种资源管理工具，最理想的策略依靠可用的计算资源以及服务质量的需求。&lt;/p&gt;

&lt;p&gt;上面说到线程对应任务无限制会对系统资源造成压力压垮系统，所以产生了线程池这个概念。线程池管理着一池相同的工作线程。通常线程池和任务等待队列亲密无间。工作线程的生命简单:从工作队列中请求下一个任务，执行它，再回线程池等待另一个任务。
用线程池的好处有很多，比如复用已经存在的线程，这样就不需要反复创建和销毁线程。通过调整线程池的大小，能充分的利用cpu，让其处于饱和状态，又恰到好处的不至于让你的应用出现OutOfMemory，或者线程间竞争资源过于激烈。类库提供了多种线程池，newFixedThreadPool , newCachedThreadPool ，newSingleThreadExecutor，newScheduledThreadPool，各有其特征，在此不多写。
用线程池代替线程对应任务的优势是提高了系统的稳定性，不会再创造成百上千的线程挤垮cpu和内存，并实现了优雅降级的限流。&lt;/p&gt;

&lt;p&gt;Executor的生命周期控制关系到JVM。如果线程没有终止，那么JVM也不会终止。生命周期基本有三个状态:running，shutting down，terminated。对于生命周期的控制，能做到优雅关闭，即等待开始的任务完成同时拒绝提交新任务，也可直接关闭所有任务。&lt;/p&gt;

&lt;p&gt;从某些方面来说，在处理延时以及周期性的任务上，ScheduledThreadPoolExecutor比Timer有优势。例如Timer是单线程的，处理时间任务可能会导致拖延以及分配不均。但是TimerTask则是多线程同时进行避免了任务等待。另外，如果Timer遇到异常，则很可能不不捕获，导致整个进程就取消影响所有任务。TimerTask则会遇到线程泄漏这个问题，后面章节再聊。&lt;/p&gt;

&lt;p&gt;Chapter 7.  Cancellation and Shutdown&lt;/p&gt;

&lt;p&gt;以前都是说开始容易结束难，现在也有说难的不是结束而是怎么开始。总之都有道理了。在Java进程里终止线程还是比较绕的事情。Thread.stop()是被废弃的方法，原因是其非常的不安全不礼貌。替代办法是用中断(Interruption)，是一种合作机制让线程告
诉其他线程停止现在所在做的事情。&lt;/p&gt;

&lt;p&gt;取消任务的原因很多，比如用户请求取消，时间限制取消，应用事件取消，错误，关闭。&lt;/p&gt;

&lt;p&gt;中断机制是实现取消行为最明智的方法。调用Interrupt方法不会强制线程终止所在做的事情，而是传递需要中断的请求，改变isInterrupted的状态。线程能在下一次更合适停止的时候停止。有些方法，例如sleep，join，wait，会抛出InterruptException以及改变中断状态。&lt;/p&gt;

&lt;p&gt;响应中断方式两种，1)传播它，让你的方法是中断阻塞式的。method() throws InterruptedException {} .2)用变量存储状态，传递给更高一级的代码层。在清楚某线程中断策略后方可使用中断。&lt;/p&gt;

&lt;p&gt;第7章看得好累，不想多写跳第下章去了。Java没有提供抢占机制来结束多线程，而是以协作机制来替代，利用FurtureTask和Executor框架能比较方便的取消任务和服务。&lt;/p&gt;

&lt;p&gt;Chapter 8. Applying Thread Pools&lt;/p&gt;

&lt;p&gt;任务类型和执行策略有潜在的耦合。任务特性需求的执行策略大致分几种：任务依赖型，任务受限线程型，响应时间敏感型，用ThreadLocal的任务。&lt;/p&gt;

&lt;p&gt;线程池应用在任务类型一致以及独立的情况下效果最好。有死锁限制的任务相互依赖，最好用无界的线程池，否则可能会卡死。长时间执行的任务也会把线程池弄的阻塞，需要设置时间限制。&lt;/p&gt;

&lt;p&gt;线程池开多大合适?如果是纯计算偏向的，线程数设置为Ncpu+1就可以了，所有cpu都在工作以及多加一个防止一些缺页中断发生时替补进去不浪费时间。但是对于有I/O操作以及阻塞的任务，就需要更多线程来提高效率。公式如下:
Nthreads = Ncpu * Ucpu * ( 1 + W/C )
Ucpu 代表想要的cpu使用率介于0%~100%
W是cpu等待时间，C是cpu计算时间
当然这也只是一个推算与CPU相关的，还有与网络，数据库，内存等相关资源也会影响到计算。例如线程池大于连接池，那么连接池就是瓶颈，反之，则是线程池是瓶颈。&lt;/p&gt;

&lt;p&gt;线程池执行器的构造函数参数如下:
public ThreadPoolExecutor(&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         int corePoolSize, 
         int maximumPoolSize,
         long keepAliveTime,
         TimeUnit unit,
         BlockingQueue workQueue)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;corePoolSize是保留的线程数，maximumPoolSize是线程池最大数，keepAliveTime以及unit分别表示存活时间以及时间单位，workQueue表示的是存放任务的队列。&lt;/p&gt;

&lt;p&gt;任务队列有三种，有界队列(bounded Queue)，无界队列(unbounded Queue)以及同步队列(synchronous Queue)。有界队列对于资源控制很有帮助，网络服务基本都用有界防止攻击，但在任务有互相依赖的情况下容易造成死锁。无界队列很好，但过大的负载会对环境造成压力挂掉。同步队列不算真正的队列，在有空余线程时，才放入一个任务让线程执行，否则执行饱和策略。&lt;/p&gt;

&lt;p&gt;任务队列装满了以后，多余的任务怎么办，这时候用到饱和策略(Saturation Policies)。在ThreadPoolExecutor中setRejectedExecutionHandler()设置。常用的几种模式，中止抛出异常(AbortPolicy), 主线程执行(CallerRunsPolicy), 安静忽略(DiscardPolicy), 扔掉将要执行的任务，提交新任务(DiscardOldestPolicy)。&lt;/p&gt;

&lt;p&gt;Executor是强大灵活应用于并发任务执行的框架。提供了很多调整选项，比如创造销毁线程的策略，处理任务队列以及处理任务的策略。虽然是最强大的框架，但一些设置的组合重叠效果会不佳，比如特殊的任务需要特殊的执行策略，一些参数的组合会导致产生奇怪的结果。&lt;/p&gt;

&lt;p&gt;Chapter 9.GUI Applications 跳过，我和图形界面暂时没有什么缘分。&lt;/p&gt;

&lt;p&gt;2/4 to be continue.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我的2012</title>
   <link href="http://deanbear.github.com/2013/02/08/my2012"/>
   <updated>2013-02-08T00:20:54+08:00</updated>
   <id>http://deanbear.github.com/2013/02/08/my2012</id>
   <content type="html">&lt;p&gt;我是不信世界末日这一套的。我从小就觉得，既然我来到并且活在这个世界，肯定是有某种意义的，在我未完成我应该要完成的虽然我暂时也不知道是什么的意义之前，世界末日怎么可能会来。所以2012年，我正常的毕业，工作，当然，并没有结婚…
明天就过年了，今天最后一天上班发一篇文，回顾一下我的2012。想到什么就写什么，思路比较杂，还要赶火车呢。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;2012年的第一天，我在福州，看着陈奕迅演唱会跨年。这本来是挺悲伤的事情，2张票，1个人，不多说什么了。但是后来因为多了一张票在豆瓣上面约人去跨年看演唱会，结果多认识了两个挺厉害的朋友。就凭这，也是很值得表扬的，以及我乐观向上的生活态度也牛逼的闪闪发亮。很开心认识新朋友。&lt;/p&gt;

&lt;p&gt;2012年的最后一天，我在珠海，住在中山大学宾馆，对面楼的两小情侣开房没有拉窗帘，我表弟以及他的同学在这边的楼兴奋的又喊又叫，我则哭笑不得。本来他们有场跨年音乐会的，但是有个同学在年底的时候跳湖自杀，见不到2013年的太阳了。给2012蒙上了一层阴影，音乐会也取消了。2012年底的时候也听闻一个认识但不熟的女生去世的消息，所以我有的时候会想，seize the day。&lt;/p&gt;

&lt;p&gt;上半年我还在边读大四边实习。因为学校没有课只剩毕业论文了，所有的心思都扑在工作上。一月份的时候让垂直市场mei.tmall.com上线后，连部门年会也没参加就逃回家过暑假了。然后过完年在家多赖了会儿才回来上班。一边赶毕业设计一边赶后来天猫预售的雏形万人团项目，那段时间算是2012最充实的日子了每天都是饱和状态。甚至前一天是毕业答辩，毕业答辩后又匆匆赶回公司，因为第二天项目就上线了，当然一切顺利。&lt;/p&gt;

&lt;p&gt;毕业设计我就搞了个网站，有一套商品发布，商品详情，以及听起来很厉害的商品SPU聚合整套逻辑在内。因为当时迷Ubuntu和Python就在Ubuntu上用Django框架和Haystack搜索适配器还有Solr以及MySQL搭了上面的功能。后来毕业答辩的时候，下面一堆教授其实也不大明白我做了什么，又是Linux又是搜索引擎Dump啥的，就点头啊什么的，不明觉厉大概就是如此这般了。&lt;/p&gt;

&lt;p&gt;然后我就顺利毕业，暂时结束了我的校园生活。未来有没有想继续读书，很难说，我觉得这个行业在商业公司中的成长绝对比在学校研究来的快，而且我在赶时间，希望能迅速发家致富再做我想做的事情，所以没时间是个好理由，好借口，但是学习新鲜的事物和知识，我是不会停止的，放心。&lt;/p&gt;

&lt;p&gt;接着在正式入职与毕业之间的2周，我又以“最后一个暑假”为名号，跑回家当了2周的少爷。对于即将到来的职业生涯，我也没有多想，因为实习了这么久，已经变成资深实习生了，习惯了。6月18号正式入职，公司有取花名的文化，在公司内大家称呼对方不叫名字，都叫花名。本来想叫无筵，出自九把刀的猎命师，但被别人早一个月取了。然后我就想到了让子弹飞里的九筒大哥张麻子，所以现在大家都叫我麻子。虽然大部分人都觉得很不可接受，取了这么俗气的名字，但是我妈说，专门还看了一遍让子弹飞，然后觉得这个张麻子不错，是好人。因为还是算新人必须按照传统发新人介绍邮件到整个部门，但是，因为实习了一年了，很多人都已经认识我很久了，所以大家邮件回复的内容都很搞笑，我都保存下来了，挺好的。我的第一份正式工作，名号是天猫工程师，职业生涯就此拉开。&lt;/p&gt;

&lt;p&gt;工资还没到手我就蠢蠢欲动了。六月底的时候趁着老妈和小姨去香港的机会，让带了MacBoook Pro，The New iPad，以及国庆期间让同事的妹妹带了iPhone 4S。加上我本来有的iPod Video集齐了苹果四件套，神龙没有出现可能要继续收集吧…满足了我一把数码瘾。其实我不是果粉，也不是数码发烧友。我只是想尝试下苹果的系统，确实很好用，不管是生活还是工作上都很方便。以及…确实让人觉得很高端，瞬间高富帅的节奏。但是！我大团队的老大做我对面，年底他接连买了MBP Retina，iPhone 5...现在的局面就是我的桌子上的设备虽然和他桌子上看上去一样，但其实他的东西都比我大比我薄比我屌多了...所以说这个故事就是说数码产品更新换代是很快的，可能要跟上潮流的成本是很大的。反正我以后的购买绝对不会像暴发户一样买就买全套了，实用就好，并且买些别的更有意义的东西。结果就我这想法…导致我上周又花了6千块在美国订了一把Martin DRS1吉他...T_T 花钱的理由千千万，花钱只要分分钟！&lt;/p&gt;

&lt;p&gt;下半年我也算认认真真在对待自己的工作，没有捅篓子，也经历了很多，比如惊天地泣鬼神的双十一，挺有意思的，1111.tmall.com的视频里甚至有我一帧的画面，我记得好像是1:05的地方，不忍直视啊。对于今年的工作我还是挺满意的，希望明年能发挥更大的作用，把tmall搞的更屌一些。&lt;/p&gt;

&lt;p&gt;技术上的东西，今年除了日常的工作，就了解了一丢丢的网络应用架构的知识，其实也算是耳濡目染吧，因为面对上亿PV上千万UV的时候，总会讨论考虑多些这些东西。还有就是真真正正学习了Java。还有很多东西不懂，13年再加把劲，毕竟还靠这门手艺吃饭。13年还想学一些和移动互联网有关的东西。不要跟随潮流，但要略知一二，不然就闭门造车了。&lt;/p&gt;

&lt;p&gt;生活方面，单身汉嘛，能简就简。不算卫生但也绝不是邋遢。有固定的朋友圈子，每周基本都有出去活动，聚聚吃吃饭，喝喝酒打打麻将什么的也很有意思。2012年除了工作只强调两个事情，一个是健身，一个是吉他。夏天坚持了2个月早起跑步，甚至买了双ASICS的球鞋，那时候感觉很棒，人特有精神的一段时间。但是后来觉得练肌肉比较重要，就又练肌肉练到秋天，冬天刚开始是晚上练，结果抗不住冷，又慢慢停下来了…等春天稍微暖和一点，再继续。吉他呢也是时断时续，下半年之后买了伯克利吉他教程，练习基本功先扎实了。等马丁吉他到了，一定也要坚持下去。所以坚持对于我来说，还是有点难度的，我希望我在2013年还能坚持做一些只有坚持做才能做到的事情，健身和吉他，一定会继续下去。&lt;/p&gt;

&lt;p&gt;感情方面，还是没有女朋友，随缘嘛。顺其自然就好，我们又不赶时间。还有很长的路要走，慢慢来，比较快。&lt;/p&gt;

&lt;p&gt;今年我觉得自己做的不够以及觉得很有必要做到的事情，是下面这篇豆瓣上的文章说的http://www.douban.com/note/239806143/  。能控制住自己情绪的人比拿下一座城池的英雄还要伟大。
—— “一个人最大的勇敢，不是打败、征服别人。而是打败、征服自己的意气。一个人在言辞激昂的时候，能截然打住；在意气慷慨的时候，能翕然收住；在怒气沸腾的时候，能廓然消住，这种人，不想成为传奇都不行。”
年龄也不小了，我也要成为这样的人。&lt;/p&gt;

&lt;p&gt;2012大概就是这样了，可能漏写了一些东西，也有隐藏了一些东西。没有关系，不用沉浸在过去，向前面看，还有很多事情等着要发生，很多故事要写要听要开心。&lt;/p&gt;

&lt;p&gt;新年快乐，祝福，以及在新的一年里一切顺利。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java NIO 简要</title>
   <link href="http://deanbear.github.com/2013/01/14/java-nio-brief"/>
   <updated>2013-01-14T19:54:01+08:00</updated>
   <id>http://deanbear.github.com/2013/01/14/java-nio-brief</id>
   <content type="html">&lt;p&gt;来源于Java 1.4的java.nio软件包，被命名为New I/O，随着时间流逝，已经不算New了，称为Non-Blocking I/O还是更合适一些。&lt;/p&gt;

&lt;p&gt;Java nio的三个核心：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Buffer&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Channel&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Selector&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Buffer包装了基本数据元素数组对象，处理数据缓存，作为一个缓冲区，是nio数据读或写的中转地。&lt;/p&gt;

&lt;p&gt;Channel提供了操作文件描述方法，实现类调用底层操作系统低级IO方法read，write，处理Buffer对象读写，是Buffer对象的唯一接口。是数据的源头或者数据的目的地。
&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/6fbda5afgw1e0sy54f9d8j.jpg&quot; alt=&quot;Buffer&amp;amp;Channel&quot; /&gt;
Buffer与Channel提高了I\O效率，Buffer以数据块代替了字节传输数据，而Channel作为双向通道，同时能检查Buffer块是否准备完毕，如果没有则返回执行其他任务等待下次轮询或者通知，而不阻塞在此等待数据，这就是非阻塞I\O。&lt;/p&gt;

&lt;p&gt;但NIO真正厉害的，精髓所在是第三个核心，Selector。有了Selector，将SocketChannel注册到Selector上，并标明SelectorKey关注的是哪类数据操作(读，写，建立连接，接受连接等)。Selector筛选准备好的Socket，提供给工作线程进行逻辑加工响应请求，这就可以将NIO衍生到Web服务的解决方案，即是NIO的卖点：I/O multiplexing(IO多路复用) + Non-blocking I/O(非阻塞IO)。&lt;/p&gt;

&lt;p&gt;Selector用到的设计模式是Reactor模式。Reactor模式翻译为反映堆模式还是准确的。Reactor模式是对多个同步事件进行分拣和派发。做一个比喻就是，一个人去钓鱼，撑出了好多支的鱼竿，然后就一边和旁边的MM聊天，一边观察这一排的鱼竿有没有鱼上钩的，如果其中有鱼竿有动作，那么就把鱼钓上来。在这里，鱼相当于数据或者请求，鱼竿代表Socket Channel，而人，就是Selector。这个组成就是一个典型的Reactor模式。这个比喻也是现在以NIO为基础的服务器的大致结构。
&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/6fbda5afgw1e0sy54sx1dj.jpg&quot; alt=&quot;Old IO &amp;amp; New IO&quot; /&gt;
传统的服务器，如Jboss，有多少个请求连接，就创建多少线程，分别处理请求，当请求连接遇到网络问题时，则线程阻塞等待。在高并发的情况下，由于阻塞造成大量请求堆积，以及频繁的线程上下文的切换占用资源，对于服务器来说都是致命的。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;如果换成NIO模式的处理请求，则是由一个线程统一管理所有进来的连接，这个线程持有的Selector对连接进行轮询，整理出已经准备完毕的连接，并派发给工作线程，让工作线程处理请求所想要的逻辑并响应结束掉这个连接，以便工作线程重复使用，接入下一个请求。将接收请求和处理请求两个阶段解藕，管理请求的前台线程和处理请求的后台线程分工合作，让服务器的资源得到合理使用。Tomcat是支持NIO的服务器，而Jetty则是支持NIO的Servlet容器。而Netty，Mina，Grizzly等都是以NIO原理为基础的框架，能依场景需求做出定制化的服务器端满足需求。&lt;/p&gt;

&lt;p&gt;综上所述，NIO带来了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免不必要的多线程(处理请求线程&amp;lt;连接数)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单线程处理多任务(接收请求线程一夫当关万夫莫敌)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非阻塞IO(线程处理IO阻塞来去自由)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IO多路复用(本次阻塞也没关系，可等下次又轮询到时操作I\O)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于块传输，比流传输更高效(正常情况)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;但同时，使用NIO并不一定带来高性能，下述4个场景是根据大牛经验总结的不合适场景&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;客户端应用&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接数&amp;lt;1000&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发程度不高&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局域网环境下&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最后对于我们是否需要利用NIO框架自己搭建服务，可以套用国外网友回答&quot;到底是用Netty还是Jetty&quot;的问题：&lt;/p&gt;

&lt;p&gt;Jetty has had support for asynchronous request processing since version 6, using a proprietary API. More recent versions support the asynchronous API as part of the Servlet 3.0 API, like any other compliant implementation.&lt;/p&gt;

&lt;p&gt;Using Netty would seem like a lot of work for little gain, unless you have highly specific requirements. Otherwise, Jetty would do the job for you with minimal effort.&lt;/p&gt;

&lt;p&gt;若有高度定制化需求，则采用NIO框架自己搭建，若没有，则采用已经存在的服务器，避免重复制造轮子的过程。我暂时看不出来我们的应用有能够高度定制的地方，并且作为前端应用，搭建出符合安全，细节，以及能与原体系架构能匹配的服务器，需要花费很大的功夫，但对于性能有多少提升，并不明朗。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;既然说到NIO，再搭车说说其他几种IO。
&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/6fbda5afgw1e0t0mnlztoj.jpg&quot; alt=&quot;4 kinds of io&quot; /&gt;
看图说话，非阻塞，阻塞IO都属于同步IO，异步IO的效率远远高于同步IO。
点击&lt;a href=&quot;http://blog.csdn.net/historyasamirror/article/details/5778378&quot;&gt;这里&lt;/a&gt;，这篇文很好的解释了这4个概念。我就不重复说了，这个知识还是很重要的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>摇滚吧，邓丽君</title>
   <link href="http://deanbear.github.com/2012/12/13/letsgo_rockandroll"/>
   <updated>2012-12-13T21:50:22+08:00</updated>
   <id>http://deanbear.github.com/2012/12/13/letsgo_rockandroll</id>
   <content type="html">&lt;p&gt;昨天临近下班时老李打电话给我，这是他上大学以来打给我的第一通电话。老李是我表弟，现在就读于某重点大学哲学系一年级，英语特好热爱摇滚，一心想着转专业。老李的称呼是我爸给起的，据我印象是由于他六七岁时照了一张姿势神态和老毛很像的照片，结果老李老李就从小叫到大。他直奔主题问我最近在干嘛。我当然回答在上班。他说再具体点。我被问的莫名其妙。就问你在关心啥。他说听说你在组乐队？我顿时心头一热，虎躯一震，问你怎么知道。他问如何了？我随口说鼓手找不到。结果他真信了直问其他人都齐了包括贝斯手吗想玩什么风格的？我说其他人好找，问题是还没组呢但你怎么知道我有这个想法？他说，我妈听你妈说的，说你打算工作几年早点退休搞乐队去...后面的话题就他最近练吉他遇到的瓶颈以及大学生活我作为前辈教导了一番并告知元旦放假可能去广东看看他才挂了电话。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;边打电话边和朋友约去古荡吃鸭头炒粉干坐定说到组乐队的事他们说对你无语了。其实我觉得这个反应才算正常，而不是打电话问我哥听说你组乐队了或者到处说我儿子以后要组乐队。老李因为热爱摇滚在学吉他这样兴致勃勃也算情有可原。但我妈为什么知道我搞音乐的想法还到处乱说？前几天和她打电话聊到最近想买把贵些好些的新吉他。她说终于不买数码产品啦？我说是，苹果产品都买了差不多了没兴趣买别的了，要干正经事了。然后血一热巴拉巴拉把我埋在心里的部分梦想都说了。我说想拍电影想搞音乐，当然是在我有一定经济基础的前提下，这个行业干个几年搞笔大的就去做我想做的事情去。我妈笑着说这样人生才丰富。当时我只是挺开心的说是的我就是这么想的。现在回想起来却好感动。她是真的有认真在听我的梦想并且没有嘲笑我的不切实际。她到底是认真对我二姨诉说我的伟大理想还是只是茶余饭后的闲扯话题呢，但最起码她没有反对。不禁想到如果我高中的时候对她说这样的话她会不会吼我快点认真读书去想七想八干什么之类的话呢。时光悄悄改变一切啊。&lt;/p&gt;

&lt;p&gt;当我大三开始玩吉他时，我妈有感叹过小时候让你太野了打什么篮球应该送去学钢琴但是家里没钱这种话。也就是说其实我错过了十几岁最适合玩音乐的时间段。到了大三买了把Talent，摸了两年吉他，只会弹些简单的曲子抓简单的和弦，到最近才真真正正的开始学五线谱。当Rocker玩Band这种想法好像太过做梦了。但是想实现这个想法的冲动越来越强烈。大概是因为这几个月看了很多演唱会的Live，从GreenDay到LinkinPark到Coldplay还有团团团团团超级趴。特别是看完了Coldplay Live 2012后。震撼到我了。这真的是一件很厉害很有趣很激情很热血能把妹还能改变的世界的事情啊。所以我下定决心，要好好学吉他，好好学音乐，学写歌。然后说不定有朝一日就能把遥不可及的愿望实现，而不再只是幻想。20岁能摇滚，30岁了也能摇滚。生命不息，摇滚不死。我不赶时间，慢慢来，比较快。以前我很讨厌把梦想说出来，会觉得不好意思，没做到说这么多空话干嘛。现在我觉得说出来反而更好，因为被说出来的梦想，就好像被监督了，必须要尽力去实现说到做到的诺言更加具有威慑力。反正梦想这种东西，没做到权当我吹牛，做到了算我牛逼。我会尽力尽力尽力尽力。&lt;/p&gt;

&lt;p&gt;昨天老马当选2012CCTV中国经济年度人物，和王健林的对话很有意思。王健林说马云太时尚，没想到穿成这样来颁奖(老马没穿西装)。老马回答说你觉得我穿的不对吗？其实我们努力的一切的目的，就是可以做自己，我觉得穿西装不像自己，穿着这个特像自己，所以穿成这样。这段话真的很赞。努力的一切的目的就是可以做自己。做自己想做的事情，就是一种做自己。挺好的。&lt;/p&gt;

&lt;p&gt;最后昨晚睡觉时，我又回想了一遍。发了短信给老李，内容如下：&lt;/p&gt;

&lt;p&gt;M:British Rock, perhaps Punk. I don't know. Now my favorite band is Coldplay.&lt;/p&gt;

&lt;p&gt;Li:Punk is brilliant.luv whatshername from greenday. night bro, looking forward to ur dropping by 1.1&lt;/p&gt;

&lt;p&gt;M:梦想遥远，尽力而为&lt;/p&gt;

&lt;p&gt;Li:谢谢哥&lt;/p&gt;

&lt;p&gt;开始了就不迟，希望一切顺利，Let's go ，Rock'n'Roll.
*『摇滚吧，邓丽君』文章名字来源于九把刀&amp;lt;猎命师&gt;卷3，乌拉拉说的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java并发编程笔记-PART I.基本原理</title>
   <link href="http://deanbear.github.com/2012/12/04/java-concurrency-in-practice-part-i-fundamental"/>
   <updated>2012-12-04T01:25:40+08:00</updated>
   <id>http://deanbear.github.com/2012/12/04/java-concurrency-in-practice-part-i-fundamental</id>
   <content type="html">&lt;p&gt; 学了好几年的编程，对于多线程一直没有进门，反复看了好多Java入门书籍顺带的多线程，无法顿悟其奥义。这本Java Concurrency In Practice，希望能解决我多年来的苦恼，所以好好读，做读书笔记，概括每章节的内容。一共有4个部分组成，每个部分一篇笔记。&lt;/p&gt;

&lt;p&gt;Chapter 1 - Introduction&lt;/p&gt;

&lt;p&gt;这章比较简单如小标题，就是介绍多线程。由于以前的计算机比较落后都是单进程在跑，后来多核CPU出现了，多进程出现了，CPU处理任务的粒度越来越小了，非阻塞IO出现了，渐渐的多线程也变得越来越重要了。那以人的直觉以及处理事情的方式，基本处于单线程，所以我们不能以人类的思维来编程，因为这样可能会浪费99%的CPU资源，同时拖延任务处理时间。应该让计算机更有效率的处理问题，这里随便插一句，其实计算机本身没什么屌的，所有厉害之处就是它做算术比人类快了n次方倍，所以它牛。&lt;/p&gt;

&lt;p&gt;再分析了一遍Java多线程是把双刃剑。&lt;/p&gt;

&lt;p&gt;列了几点好处：1.能高效利用多核处理器2.编程模型更简单3.处理异步事件更简洁4.用户界面反应更快捷。&lt;/p&gt;

&lt;p&gt;也列了几点坏处：1.线程安全风险2.活性(活锁,死锁,饥饿)风险3.性能风险。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;最后总结说多线程无处不在。我忽然就记起来最早学习多线程是初中的语文书= =.那是个单元小结，告诉我们怎样正确的泡茶:在等待开水烧开时，把洗茶杯倒茶叶之类的事情都做了，然后就可以泡茶了。好像是这样的剧情。在本章节里也出现了这个英语版...回想起来觉得好有趣，语文课学了计算机的知识，真是科学哲学不分家啊。&lt;/p&gt;

&lt;p&gt;PART I fundamental 第一部分(2-5章节) 基础原理&lt;/p&gt;

&lt;p&gt;Chapter 2 - Thread Safety&lt;/p&gt;

&lt;p&gt;线程安全是多线程编程中最需要考量的问题，都不能保证程序正确，那多线程了有个屁用。那到底什么是线程安全?解释这个概念不容易，作者给了这样的定义:A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.(一个类如果是线程安全的，那么在运行环境无论多个线程按时序或者交叉的调用它，它的表现都正常，并且无需在调用这个类的线程代码里增加同步或者其他协调的代码。)&lt;/p&gt;

&lt;p&gt;1.线程安全是要保证原子性(Atomicity)的，因为有多线程操作，必须做到操作不可拆分，否则容易做到一半频道切换给别的线程了，就捅篓子了。&lt;/p&gt;

&lt;p&gt;2.上面的切频道这个就涉及到竞争条件(Race Condition)：结果必须依赖事件发生的时间而定。若做一半切频道再回来可能结果就会发生不同。往往会造成莫名其妙的错误。&lt;/p&gt;

&lt;p&gt;3.上面的情况往往是在做Compound Actions(组合操作)的会遇到竞争条件，所以我们必须确保把多个动作捆绑起来一起完成，要么不做，要么做全套。&lt;/p&gt;

&lt;p&gt;4.做全套用什么方法比较合适，锁的概念就出现了。在执行一段逻辑代码时，我们给这段逻辑加锁，加锁的意义就在于，这段逻辑同时只能有一个线程执行。这就是同步机制(Synchronizaiton)。&lt;/p&gt;

&lt;p&gt;5.虽然只能由一个线程调用，但如果一个线程循环调用了这段逻辑怎么办?Reentrancy(可重入)意味着在因为循环调用或者系统中断后依然能得到正确的结果，JVM会给一个计数，线程增加调用则+1，结束调用则-1，当计数恢复为0，则解锁。&lt;/p&gt;

&lt;p&gt;6.并不是只有在写入数据才需要锁，这个想法是错误的。在多个线程同时对一个数据进行操作时，我们必须要用锁来保证这个数据的状态，即用锁维护状态(Guarding State With Locks)&lt;/p&gt;

&lt;p&gt;7.线程安全往往是在减低性能的，一段被加锁的逻辑往往是瓶颈所在。所以在用同步机制时必须很清楚知道程序的逻辑是否全部需要，应该考虑在尽量少的部分用，并且不在一些耗时很长的地方(如等待IO处理之流)。&lt;/p&gt;

&lt;p&gt;8.在做到线程安全的基础上，尽量少的阻碍性能，不要让多线程的代码最终变成了单线程效果。&lt;/p&gt;

&lt;p&gt;Chapter 3 - Sharing Objects&lt;/p&gt;

&lt;p&gt;既然多线程，肯定会遇到多个线程共享一个对象的情况。&lt;/p&gt;

&lt;p&gt;1.可见性(Visibility)，是指当对象改变时，任何线程都能知道，同步机制可以做到。当多个线程共享对象时，最稳妥的方式就是加同步机制。这涉及到过期数据(Stale Data)，某一线程读取到的是改变之前的对象数据，这在高速计算中是不能容忍的。double和long型不是原子的，因为它们是64位，JVM的原子操作是32位的，所以在多线程中也必须注意这个，加锁或者加volatile修饰符。锁不是只针对互斥现象，它也关系到内存可见性，为确保线程能得到到最新的共享变量，读写线程必须用公共锁保持同步。&lt;/p&gt;

&lt;p&gt;2.volatile修饰符，是Java自带的，对比synchronized，它是一个轻量级的同步机制。它不会上锁所以无法对线程造成阻塞，所以在性能上是优于synchronized的。锁能保证可见性与一致性，但volatile只能保证可见性。volatile变量在多线程情况做自增(++)运算时可能会发生错误，因为无法保证原子性，除非自增操作只有单一线程操作。如果牵涉到不变式(X &amp;lt; Y)也是不适用volatile的。总结一下volatile的使用：&lt;/p&gt;

&lt;p&gt;a).写变量不依赖现有值或者确保只有单个线程会更新值。&lt;/p&gt;

&lt;p&gt;b).变量不参与不变式。&lt;/p&gt;

&lt;p&gt;c).在访问变量时不需要其他原因的锁定。&lt;/p&gt;

&lt;p&gt;3.把成员变量展现给其他类，称为公开(Publication)，但是在对象没有完整构造之前成员变量被引用了，则称为逃逸(Escape)。&lt;/p&gt;

&lt;p&gt;4.线程限制(Thread Confinement)，当可以不用共享时，使用线程限制，让多线程各行其道互不干扰。&lt;/p&gt;

&lt;p&gt;a)非正式线程限制(Ad-hoc Thread Confinement)，在局部使用单线程…&lt;/p&gt;

&lt;p&gt;b)栈局限(Stack Confinement)，通过本地变量创建拷贝某个共享对象&lt;/p&gt;

&lt;p&gt;c)ThreadLocal , Java类型，一个线程对应一个ThreadLocal，类似本地变量。&lt;/p&gt;

&lt;p&gt;5.不变性(Immutability)，常量对线程来说是绝对安全的。善用Final变量。&lt;/p&gt;

&lt;p&gt;6.安全公开(Safe Publication) 安全公开一个对象，在同一时刻此对象的引用以及状态都必须对其他线程可见，一个完整构建的对象可以在如下条件被安全公开:&lt;/p&gt;

&lt;p&gt;a)从静态初始化程序初始化对象。&lt;/p&gt;

&lt;p&gt;b)存储引用用volatile修饰符或AtomicReference类型引用。&lt;/p&gt;

&lt;p&gt;c)存储引用用final修饰符修饰&lt;/p&gt;

&lt;p&gt;d)存储引用有锁守护&lt;/p&gt;

&lt;p&gt;7.在并发编程中共享对象最有效的策略如下：&lt;/p&gt;

&lt;p&gt;a)一个线程唯一拥有一个线程限制的对象，只有这个线程能对其进行修改。&lt;/p&gt;

&lt;p&gt;b)只读对象可以被任何线程访问并不需要增加同步机制。&lt;/p&gt;

&lt;p&gt;c)线程安全对象，有内在同步机制，不需要更多的同步机制。&lt;/p&gt;

&lt;p&gt;d)锁守护的对象。&lt;/p&gt;

&lt;p&gt;Chapter 4 - Composing Objects&lt;/p&gt;

&lt;p&gt;这章巴拉巴拉一堆就是说，用线程安全的组件或者变量，来组装一个更大的组件，对象或者程序，这样我们就不用费心分析我们的程序是否是线程安全的。内容跳过…因为我也看的迷迷糊糊的。&lt;/p&gt;

&lt;p&gt;Chapter 5 - Building Blocks&lt;/p&gt;

&lt;p&gt;这章重点介绍了并发的构成模块，以及使用库里提供的并发类时会遇到的一些问题。&lt;/p&gt;

&lt;p&gt;1.同步集合载体(Synchronized Collections)不能保证在使用的过程中一定是线程安全的。sychronized类方法只能保证在同一个时间片内此类实体被一个sychronized方法调用，但不能保证调用顺序是你所设想的，比如在调用size()方法后再调用get()时，中间可能会被remove()打断过，结果错误还是不能避免的会发生。&lt;/p&gt;

&lt;p&gt;2.在调用多个synchronized方法并且前后有关联时(比如get()与remove())，最好用到同步块，锁定操作的集合对象就能避免发生不同步问题。&lt;/p&gt;

&lt;p&gt;3.使用迭代器(Iterators)时，部分迭代器(应该是大部分具体我不是很清楚)有fail-fast机制，即在用迭代器时若改变了原集合的结构，则立即抛出Concurrentmodificationexception，但是若用iterators自带的remove()等，则不会抛出异常，因为这个操作和迭代器维护着是同一套索引。&lt;/p&gt;

&lt;p&gt;4.还要注意一些隐蔽的迭代器，比如在集合的toString()方法中就用到了迭代器，这经常会忽略在同步块之外，造成一些显示错误。&lt;/p&gt;

&lt;p&gt;5.Java 5.0增加的java.util.concurrent.*包里有很多好东西。并发更强悍的并发集合(Concurrent Collections)在某些场景可以很好的取代同步集合(Synchronized Collections). http://www.ibm.com/developerworks/cn/java/j-5things4.html 这篇文章对CopyOnWriteArrayList，BlockingQueue，ConcurrentMap等集合容器都做了讨论，更多细节可以搜索，我还打算写一篇ConcurrentHashMap解析的文章，因为这个类真的蛮经典的。&lt;/p&gt;

&lt;p&gt;6.生产者-消费者模式(Producer-consumer Pattern)，学过操作系统原理都应该知道，这是建立在上述所说的阻塞队列(Blocking Queue)上的一种模式，阻塞队列又分位无界队列和有界队列，有界队列是一个很棒的资源管理工具，让程序更加健壮可用。&lt;/p&gt;

&lt;p&gt;7.阻塞方法(Blocking Method)能被中断(Interrupt)，阻塞状态是指BLOCKED，WAITING，TIMED_WAITING.&lt;/p&gt;

&lt;p&gt;8.Java库提供了很多同步装置类，方便管理联系各线程状态。&lt;/p&gt;

&lt;p&gt;a)Latches(锁存器) , 锁存器就像一个门，在到最终状态之前，门是关着，任何线程都不能通过。到达最终状 态后，再也不能改变，锁存器将保持打开状态允许线程通过。CountDownLatches的例子很多 自行搜索。&lt;/p&gt;

&lt;p&gt;b)FutureTask，类似给异步请求做了代理，Furture.get依赖于任务状态，若已完成则立即返回，否则阻塞直到返回结果。在程序中，可以先创建FutureTask，再执行其他动作，等到要用到Task时，再get，相当于并发的异步请求。&lt;/p&gt;

&lt;p&gt;c)Semaphores(信号量)，学过操作系统原理的也肯定熟悉，信号量可以控制激活有限数量的线程，让机器在满负荷而不是超负荷工作。比如数据库连接池就可以用信号量控制连接数。详细就不说了，比较常见。&lt;/p&gt;

&lt;p&gt;d)Barriers(栅栏)，相对比Latches，是其增强版，Latches只能用一次，Barriers可以重复使用，Latches是对事件触发，Barriers是对线程触发。集齐七个线程，才能召唤神龙…只有等所有线程都完成时，Barriers才能让他们通过，进行到下一步。&lt;/p&gt;

&lt;p&gt;Summary of Part I&lt;/p&gt;

&lt;p&gt;第一部分基础原理就结束了，总结时间，原文几个点很到位，原封不动的翻译到这儿。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;记住这是互斥状态，二货。(*It's economy,stupid典故戳中笑点啊混蛋) 所有的并发问题都归结于处理互斥状态的协调，越少互斥状态，线程越安全。&lt;/li&gt;
&lt;li&gt;字段标识为Final除非它是变量。&lt;/li&gt;
&lt;li&gt;不可变对象是线程安全的。不可变对象对于多线程有着可观的简化效果，它们更简单更可靠，并且能在不加锁以及无需防御性拷贝的情况下共享。&lt;/li&gt;
&lt;li&gt;对于处理复杂问题，封装十分有效。你可以把所有数据存在全局变量中来打造一个线程安全的程序是没有意义的。往对象封装数据对于保护他们的不变量变得更简单，往对象封装同步语法对于遵守同步协议变得更简单。&lt;/li&gt;
&lt;li&gt;对每个易变变量加锁守护。&lt;/li&gt;
&lt;li&gt;组合动作(事务)持有锁。&lt;/li&gt;
&lt;li&gt;能让多个线程在没有同步机制的情况下访问易变变量的程序是2B程序。&lt;/li&gt;
&lt;li&gt;不要想当然的认为不需要同步机制。&lt;/li&gt;
&lt;li&gt;设计构造中明确说明线程安全问题的，可以证明你的类是线程不安全的。&lt;/li&gt;
&lt;li&gt;明文记录同步策略。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;1/4 to be continue.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>搜索引擎术语</title>
   <link href="http://deanbear.github.com/2012/11/18/search_engine_glossary"/>
   <updated>2012-11-18T21:50:40+08:00</updated>
   <id>http://deanbear.github.com/2012/11/18/search_engine_glossary</id>
   <content type="html">&lt;p&gt;今天登到Google云盘，看到了这篇文章，是半年前写毕业设计时要用到搜索引擎时随手翻译的，挺好的，贴上来。时间过的好快T——T.&lt;/p&gt;

&lt;p&gt;----------------白驴过隙的分割线--------------------&lt;/p&gt;

&lt;p&gt;英文原文：http://django-haystack.readthedocs.org/en/latest/glossary.html&lt;/p&gt;

&lt;p&gt;搜索领域充满了专属术语与专属定义。这可能会是一个众多开发都不熟悉的领域。接下来介绍一些常用的术语以及它们的意思。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引擎(Engine)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这里的引擎特指搜索引擎。作为Haystack的目标对象，它是一个第三方的搜索解决策略，可能是完整的服务（如Solr）,或者是一个库来构造内建引擎（如Whoosh)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;索引(Index)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;索引是指被引擎使用的数据存储(datastore）。它的体系结构在不同的引擎是有所不同的，但是总的来说，都是以类似文件的方式存储的。索引是Haystack里所有信息的源头。
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;strong&gt;文件(Document)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;文件本质上来说是索引中的一条记录。它通常包括至少一个文本BLOB(binary large object),用来作为搜索的主内容(primary content)，也可能会依附一些额外的数据。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;语料库(Corpus)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一个文件集合的术语。当涉及到搜索所存储的文件时(不是指存储技术实现),这个词经常会被用到。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;字段(Field)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在索引中，每个文件可能把额外的数据作为一个字段。字段有的时候也称为属性(attribute)，通常代表元数据(metadata)或者文件的额外内容。Haystack可以利用这些字段做过滤和展示。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;分词(Term）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在搜索查询中用到的一个单词字符串。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;词根截断转换(Stemming)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在单词有任何词根时转换。这通常取决于语言，但在英语中，这个行为通常是指去除复数形式与时态等等。例如，在英语中长颈鹿复数'giraffes'会转化为'giraffe'.相似的，感叹的名词'exclamation'也会转换成动词词根'exclaim'。这对找不同文档中出现的不同变体词有很大的帮助。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;升权(Boost)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Boost提供了一种方法，通过从搜索查询中提取出来的某些单词或者短句在结果中出现的情况来替换搜索结果。例如，如果你想给包含'斑马'的结果多一些权重，你就得为查询语句中的'斑马'指定一个Boost。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;更多类似(More Like This)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;作为检索信息与人工智能的整合，更多类似技术是根据询问中的文件，在索引中查找其他相似度很高的文件。这个对程序根据用户正在浏览的文件内容生成的相似内容列表有很大的帮助。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;切面(Faceting)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Faceting是一种提供用户深入你语料库内容的渠道。最简单的形式就是给定一个查询反馈用户一个文件集合计数的结果，这些计数可以作为回调给用户，允许用户选择感兴趣的切面来继续搜索结果并且&quot;钻进&quot;结果中。
一个例子就是可以提供一个切面给author字段，返回一个作者列表以及索引中他们写的文件个数。这可以提供给用户链接，允许用户点击并且可以给予原始搜索更高的精确度输出所有关于那个作者的结果。
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>分布式系统稳定性模式-小邪[笔记]</title>
   <link href="http://deanbear.github.com/2012/10/26/note-about-distributed-system-stability-mode"/>
   <updated>2012-10-26T18:44:50+08:00</updated>
   <id>http://deanbear.github.com/2012/10/26/note-about-distributed-system-stability-mode</id>
   <content type="html">&lt;p&gt;昨天小邪讲的培训的内容，对集群大访问量的应用很有针对性的一些注意点。&lt;/p&gt;

&lt;p&gt;1.隔离。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;发生问题，能控制在一个小的范围。
物理隔离/虚拟(容器，实例，VM)隔离/流控
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.内存溢出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;代码细节，数据量，进程数控制。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.预估数量，阀值控制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;远程获取的变量需谨慎处理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.超时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QPS = 1000ms / rt(timeOutAvg) * threadCount 
*QPS越高，线程越少，越完美。
超时时间设定需合理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.流控&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;比超时更友好，有自我恢复能力
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;6.异步调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;减少响应时间，在客户端做异步调用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.限流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;限制请求数，Web服务器拦截，以QPS为准
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.降级&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对弱依赖有效/最好能做到自动降级，自动恢复
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.开关&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;手动降级，关闭服务，临时可能会忽略。需有专人负责
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.热点缓存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;容易被攻击，策略：将被攻击的或者不存在的数据放入Cache，不查询DB。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11.缓存容灾&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;多份缓存，并且有对应DB的整套缓存，能独立成为数据源
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;12.依赖Jar包冲突&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;二方包间接依赖冲突检测，mvn:dependency:tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13.内部调用优先&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;路由，同机房优先调用DB，Cache。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;14.依赖诊断和调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;接口调试（在线），一些小脚本，jsp能迅速模拟调用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15.日志跟踪&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;traceId ? 所有调用应用打日志，以traceId为Key能查询出完整请求调用日志记录。
缺点是但是日志量会很大
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;16.依赖识别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;强依赖/弱依赖/依赖系统，调用接口的统计管理。能查出系统的瓶颈。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;17.依赖简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;合并依赖，异步化依赖。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;18.发布规范
   daily/prepub/beta&lt;/p&gt;

&lt;p&gt;19.服务治理
   Admin系统  XXAdmin 白名单，黑名单之类的管理等&lt;/p&gt;

&lt;p&gt;20.容量规划
   物理服务器备机准备&lt;/p&gt;

&lt;p&gt;21.预演
   模拟正式环境处理问题，能暴露很多问题，帮助很大&lt;/p&gt;

&lt;p&gt;22.告警
   短信等，及时处理线上问题&lt;/p&gt;

&lt;p&gt;23.资源调度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;优先级资源划分，想法比较好，但比较难做到
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>组合与继承:物尽其用，各取所需。</title>
   <link href="http://deanbear.github.com/2012/09/25/composition_vs_inheritance"/>
   <updated>2012-09-25T06:32:32+08:00</updated>
   <id>http://deanbear.github.com/2012/09/25/composition_vs_inheritance</id>
   <content type="html">&lt;p&gt;    上两个星期团队对应用做了一个重构改造，主要是增加代码复用性以及减少重复编码成本。理所当然的，OOP听起来就是为这个目的而产生的。OOP的全称有几个人拼的齐?科普一把:Object Oriented Programming.在大陆翻译是面向对象程序设计，在台湾翻译成物件导向程式设计。不知道是不是耳濡目染听多了，我认为这个词大陆翻译的比较正。&lt;/p&gt;

&lt;p&gt;这个改造不是我做的，在看改造完的代码的时候，虽然觉得写的都挺合情合理的，但总觉得很怪异，又不知道该怎么表达。某天晚饭吃火锅的时候，和其他人聊起来我的看法，老蒋直接抛给我一句:&quot;你的意思就是组合比继承更适合&quot;，虎躯一震的感觉马上出来了，只怪自己书读的不够说不出来这么抽象的语句。所以我的想法就是，虽然继承是OOP的精髓所在，但是，作为杀手锏，没有必要每次都出，组合反而更加灵活适用。&lt;/p&gt;

&lt;p&gt;接着我就翻了翻 Thinking in Java ，找到了两处关于 composition(组合) vs. inheritance(继承) ，也算是比较权威的解释了，什么时候用组合什么时候用继承，心里有个数。内容如下。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;strong&gt;Part One&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Choosing composition vs. inheritance&lt;/p&gt;

&lt;p&gt;Both composition and inheritance allow you to place subobjects inside your new class (composition explicitly does this—with inheritance it’s implicit). You might wonder about the difference between the two, and when to choose one over the other.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Composition is generally used when you want the features of an existing class inside your new class, but not its interface. That is, you embed an object so that you can use it to implement features in your new class, but the user of your new class sees the interface you’ve defined for the new class rather than the interface from the embedded object. For this effect, you embed private objects of existing classes inside your new class.&lt;/p&gt;

&lt;p&gt;Sometimes it makes sense to allow the class user to directly access the composition of your new class; that is, to make the member objects public. The member objects use implementation hiding themselves, so this is a safe thing to do. When the user knows you’re assembling a bunch of parts, it makes the interface easier to understand. A car object is a good example:&lt;/p&gt;

&lt;p&gt;Because in this case the composition of a car is part of the analysis of the problem (and not simply part of the underlying design), making the members public assists the client programmer’s understanding of how to use the class and requires less code complexity for the creator of the class. However, keep in mind that this is a special case, and that in general you should make fields private.&lt;/p&gt;

&lt;p&gt;When you inherit, you take an existing class and make a special version of it. In general, this means that you’re taking a general-purpose class and specializing it for a particular need. With a little thought, you’ll see that it would make no sense to compose a car using a vehicle object—a car doesn’t contain a vehicle, it is a vehicle. The is-a relationship is expressed with inheritance, and the has-a relationship is expressed with composition.&lt;/p&gt;

&lt;p&gt;上面一坨英文的中心思想就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组合是一个显性的写法，你想要一个类的特性，就直接把它作为自己的类的成员对象。想让人访问则用public，否则用private或protected即可，非常灵活方便类与类之间没有羁绊(这是高端词汇)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继承则是一个隐性的写法，往往是在通用的基类之上添加或修改一些属性或方法，成为一个特例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组合表达&quot;含有某功能&quot;，而继承表达&quot;是某物的一种版本&quot;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;区别听起来组合的思想比组合高级一些，更抽象而且有哲学范儿。而组合则是很随意很灵活的一个过程性思维，但特管用。具体什么时候用哪个，则认真读一下Part two。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part Two&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Composition vs. inheritance revisited&lt;/p&gt;

&lt;p&gt;In object-oriented programming, the most likely way that you’ll create and use code is by simply packaging data and methods together into a class, and using objects of that class. You’ll also use existing classes to build new classes with composition. Less frequently, you’ll use inheritance. So although inheritance gets a lot of emphasis while learning OOP, it doesn’t mean that you should use it everywhere you possibly can. On the contrary, you should use it sparingly, only when it’s clear that inheritance is useful. One of the clearest ways to determine whether you should use composition or inheritance is to ask whether you’ll ever need to upcast from your new class to the base class. If you must upcast, then inheritance is necessary, but if you don’t need to upcast, then you should look closely at whether you need inheritance. The Polymorphism chapter provides one of the most compelling reasons for upcasting, but if you remember to ask “Do I need to upcast?” you’ll have a good tool for deciding between composition and inheritance.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这段我觉得写的特棒。虽然继承在面向对象语言中绝对是重中之重，考试必考。但这不代表你在任何时候任何场景都必须用它。比如说你有一个独门武功，你就不分场合不分对手的一直用，结果刚好某个对手就是你克星专拆你的绝招，那你死定了。所以说绝招不要随便放，得等到决定胜负一招定天下时用才能看出功夫的奥义。用的多不如用的少，用的少不如用的妙。所以当你要用继承关系时，你扪心自问一把:&quot;我需要向上转型吗?&quot;如果答案是肯定的，则大胆用着，如果发现其实这个类没有那么通用不会遇到要向上转型的情景，则尽量用组合吧。当然，话也不能太绝对，一切以场景为主见机行事见招拆招，肯定不会错。&lt;/p&gt;

&lt;p&gt;最后重复本文最关键的一句话：&lt;strong&gt;不必拘泥于组合方式还是继承方式，由这个类是否需要向上转型而定，就这么简单。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>谁手上没有几行难写的代码呀</title>
   <link href="http://deanbear.github.com/2012/09/13/could_you_play_better_than_them"/>
   <updated>2012-09-13T03:46:00+08:00</updated>
   <id>http://deanbear.github.com/2012/09/13/could_you_play_better_than_them</id>
   <content type="html">&lt;p&gt;这话题太大了，我没有头绪从哪里开始哪里结束哪里插入比较合适。&lt;/p&gt;

&lt;p&gt;就如这个分类名称一样，“开发乱讲”，年纪轻轻，阅历有限。只是用来专门记录开发过程遇到的问题。&lt;/p&gt;

&lt;p&gt;写到第三行了根本不知道怎么开始，满脑子只有一个中心思想:要多读书…知识才是力量。否则不管是编程还是写作，都是一个难产的过程。这么说来，其实编程和写作还是一样样的。&lt;/p&gt;

&lt;p&gt;-----------------------------------IN-----------------------------------&lt;/p&gt;

&lt;p&gt;是这样的，在手上开发维护的应用已经存在一年了，期间经过了几次优化一次大重构。承接的业务贯穿整个公司，用户访问量也大的惊人。所以得做到在不断接入新业务满足业务方的需求的同时，还得时时关注系统本身，必须能够保证应用的稳定以及性能。而且，随着应用日益重要，团队也由去年的三四个人，扩大到了今年的十个人。&lt;/p&gt;

&lt;p&gt;这样就产生了三个问题:&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;其一，因为业务承载多，应用变的臃肿起来，而且难免会有互斥的存在，需要定义优先级，有我没他一起有就是线上Bug那种。造成代码逻辑复杂。&lt;/p&gt;

&lt;p&gt;其二，因为追求访问性能以及系统稳定性的卓越，应用拆分成三个子系统，子系统之间的耦合传递，使得代码逻辑更加复杂以及更加更加复杂。&lt;/p&gt;

&lt;p&gt;其三，人多手杂，思想很难统一，人多沟通成本大人少工作辛苦，组织大了是好还是坏也很难定夺。业务多了开发编码分散，你添一点我添一点拼凑起来，罗马不是一天建起来的。&lt;/p&gt;

&lt;p&gt;嚯，上面的表述自我感觉挺良好，挺清晰的呀。总之就是作为开发者的角色，老子现在的状况是举步维艰。&lt;/p&gt;

&lt;p&gt;镜头回切，为什么会想这些呢。因为这个星期在关项目室，接入一个成交额好几个亿的促销业务。对着代码发呆思考叹气了一个下午，思前顾后，很难理顺每个业务点以及细节逻辑。陷阱太多，逻辑太绕。&lt;/p&gt;

&lt;p&gt;单纯从某个点编程，很简单。但是得与现有存在的代码融合，以及还得为未来扩展，通用，统一做考虑，就累的不行了。&quot;又不是打字员，招程序员来是让你思考的好吗!&quot;…好吧给跪了。&lt;/p&gt;

&lt;p&gt;今天在电梯里感叹，往往新起一个系统，作为开发而非架构师，从无到有还更简单些。但是这么美好的事情不可能一直发生，社团也好，生意也好，总会做大。所以创业公司多开心呀，人少业务简单工作虽然辛苦但是充满希望。一发展成大公司，条条框框以及错综复杂的业务以及部门协作，跨部门协作就更耗了。然后就会发现，整个开发周期，真正写代码的时间微乎其微，剩下的时间在开会，在发邮件，在说服兄弟部门，在和业务方妥协，在沟通，在沟通，在沟通…这就是真正的&quot;软件工程&quot;，Slogan我都想好了，“软件工程，不仅仅是编程。(Software Engineering , not just only programming.)”&lt;/p&gt;

&lt;p&gt;作为生活积极向上工作认真负责的好开发儿。我自然也是思考了一番。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;——&quot;你看看我们霸子他那个脑袋欸，他他妈每天不睡都在想啊，想组织要怎么发展。他现在一声令下细胞分裂我们马上就不是几百个人的帮派是几万人啊，我跟你说。枪一箱一箱从海上运进来堂口一个一个的开。你勒，在你的角头他妈的卖卫生纸卖高山茶收保护费，动不动就被削进去蹲。&quot;  via ［艋舺］ 灰狼大&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;挺好看的一部台湾电影，还有里面&lt;em&gt;Making love out of nothing at all &lt;/em&gt;这首曲子真心好听。&lt;/p&gt;

&lt;p&gt;...好跑题回来。&lt;/p&gt;

&lt;p&gt;那，列了三点，就有三个回复。&lt;/p&gt;

&lt;p&gt;其一，业务优先级上的东西纠结，就在楼道抽烟的时候和产品啊技术啊都聊了一把，结果大家都关注到这个问题了，有一个很理想的想法，这样的业务优先级要在开始时就控制住，在根源解决，给个独一排他的入口，直接保证接下来所有流程上的正常。因为涉及具体工作不方便透露，就只能讲的这么抽象。&lt;/p&gt;

&lt;p&gt;其二，系统本身的架构就是一门很艺术很科学的事情，能想到每个关键点才是牛逼的架构师。所以呢，这条路还很长，需要很久的积累。所以要多看书看报多学习，向身边牛逼的人物多学点…&lt;/p&gt;

&lt;p&gt;其三，这就是团队协作的精髓所在。据说印度仔在这方面很强，他们的代码都像一个模子出来的。而中国淫则是千奇百怪五花八门，再多扯就是体制和教育问题啦，收声。所以和同事多分享总结很重要。还有就是这种思考方法:&quot;产品经理总有业务规划期，既然这么多开发，到时就都是空窗期，每年不做一次重构不是浪费吗?!&quot;…这理由，老子给跪了X2。&lt;/p&gt;

&lt;p&gt;----------------------------------OUT---------------------------------&lt;/p&gt;

&lt;p&gt;说完了。一句话总结:做简洁比做繁琐难一百倍。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>嚯。终于出现了！</title>
   <link href="http://deanbear.github.com/2012/09/08/it_happends_finally"/>
   <updated>2012-09-08T05:06:00+08:00</updated>
   <id>http://deanbear.github.com/2012/09/08/it_happends_finally</id>
   <content type="html">&lt;p&gt;我不是在说姑娘，我是在说这个网站。
&quot;弄一个自己的网站&quot;在我脑子里埋了好久了。做技术的不管在论坛还是门户网站开博客总觉得不像话。一点互联网精神都没有。
懒着懒着拖着拖着昨天心一横，趁项目开始前夕的偷闲，把这个事情给办踏实了。
现在就着重描绘一下整个历史性的过程。
终于出现了。
有这么一个地方写写东西也挺好的。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;strong&gt;域名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;昨天心为什么一横呢，就是因为看到一个域名搜索框的广告，我就想着要不申请一个域名吧。然后就去到godaddy.com，搜了一下deanbear.com。嚯，被人给注册走了。然后我就想着thegreatbear.com，嚯，也被人注册走了。然后想到前段时间不是蝙蝠侠黑暗骑士崛起上映吗，the dark knight ，我干脆叫the dean bear好了。然后我就注册paypal，再注册godaddy，结果下单发现godaddy只能用信用卡和支票，我也不晓得为什么。注册了却没法下单半天烦躁着很，就逛到万网了，毕竟同属一个集团，怎么也得照顾一下呀。就花了55块买了一年的thedeanbear.com使用期。&lt;/p&gt;

&lt;p&gt;然后就到DNS的问题了，我去了dnspod.cn，挺好的，安全，纯免费，操作界面也舒服，然后我就把域名解析放在它那儿。
买域名这事儿就这么结了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主机&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;昨天在万网买完域名，万网的客服代表就打了电话问熊先生是否要怎样怎样，我就很霸气的说，&quot;不用了，我要买美国主机。&quot;...嚯。美国主机。
然后今天我就开始盘算着&quot;美国主机&quot;。先是弄清楚了VPS和主机的区别后，我就问一淘一哥们儿昆卡，我百淘同学。他推荐了homezz.com。我就上去逛了一圈，挑了一个最便宜的主机，一年100块...小空间小流量，机房在加利福尼亚哪儿我忘了，便宜是便宜，但听起来也很洋气呀。反正我现在就想写写博客而已。也没个把人看，等空间啊流量啊不够用了再换呗。接着在dnspod那把域名和主机地址关联起来，就能访问到了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;博客&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;肯定用WordPress嘛。听多了就用了，PHP的完美作品。确实很强大，我就配好MySQL数据库，把WordPress文件夹上传到服务器，浏览器页面直接安装配置完就好了，WordPress甚至还很炫耀的写出&quot;这就是五分钟安装&quot;...其他的主题啊个性化配置域名链接啊之类的都是用户交互操作，没难度。就是中文字体可能还需要调整。这个编辑器不是很适合中文发挥的感觉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好，这就是这个第一个属于我的博客网站的第一篇文。搭个博客网站真的有点简单，没有我想象中的拽，我有点失望，根本没啥值得炫耀了。
我希望接下来我能坚持更新，经常除草。不仅写技术有关的，还写些别的。总之我高兴干啥就干啥。我自个儿的地谁都管不着。
说到写东西，我爸还收藏着我大学前写的作文同时后悔当时没让我读文科也透露过我当初读文科现在说不定是一个了不起的新锐作家的后悔想法。
谁知道呢。
大家都不知道会发生什么，生活的才有意思。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>